# This is a sample spops.ini file. Its purpose is to define the
# objects that will be used in your package. Each of the keys is
# commented below.

# If you do not plan on defining any objects for your package, then
# you can skip this discussion and leave the file as-is.

# Note that you must edit this file by hand -- there is no web-based
# interface for editing a package's spops.perl (or other)
# configuration files.

# You can have any number of entries in this file, although they
# should all be members of the single hashref (any name is ok) in the
# file.
#
# Finally, you can retrieve this information as a perl data structrure
# at anytime by doing:
#
#   my $hashref = $object_class->CONFIG;
# or
#   my $hashref = CTX->lookup_object( 'object_alias' )->CONFIG;
#
# For more information about the SPOPS configuration process, see
# 'perldoc SPOPS::Configure' and 'perldoc SPOPS::Configure::DBI'


# '[% package_name %]' - Defines how you can refer to the object class
# within OpenInteract2. For portability and a host of other reasons,
# OI sets up aliases for the SPOPS object classes so you can refer to
# them from the context. For instance, if you are in an application
# 'MyApp':
#
#  my [% package_name %]_class = CTX->lookup_object( '[% package_name %]' );
#  print ">> My Class: [[% package_name %]_class]
#
#  Output: '>> My Class: [OpenInteract2::[% class_name %]]'
#
# This way, your application can do:
#
#  my $object = CTX->lookup_object( '[% package_name %]' )->fetch( $object_id );
#
# and not care about the different implementations of the '[%
# package_name %]' class and such.
#
# Note that the 'alias' key allows you to setup additional aliases for
# this object class.

#[[% package_name %]]

# class - Defines the class this object will be known by. This is
# almost always 'OpenInteract2::Blah'

#class           = OpenInteract2::[% class_name %]

# code_class - Perl module from which we read subroutines into the
# namespace of this class. This is *entirely optional*, only needed if
# you have additional behaviors to program into our object.

#code_class      = OpenInteract2::[% class_name %]

# isa - Define the parents of this class, generally used for enhanced
# functionality like full-text indexing.
#
# Note that you DO NOT have to add OpenInteract2::SPOPS::DBI,
# SPOPS::DBI, SPOPS::DBI::Pg, or any of the other ones that you
# entered in OI 1.x. This is done at runtime for you, so your objects
# will always be in sync with what databaes you're
# using. Additionally, you specify whether the object is secured using
# 'is_secure', below:

#isa             = 

# field - List of fields/properties of this object. If this is a
# DBI-based object and you specify 'yes' for 'field_discover' below,
# you can leave this blank

#field           = id
#field           = name
#field           = type

# field_discover - Whether to discover the fields for this object at
# startup. (Recommended.)

#field_discover  = yes

# id_field - Name of primary key field -- this only identifies the
# object uniquely. You still need to deal with generating new values,
# either by an auto-incrementing mechanism (in which case you need to
# use the appropriate SPOPS::DBI class) or something else.

#id_field        = [% package_name %]_id

# increment_field - Whether to use (or be aware of) auto-incrementing
# features of your database driver.

#increment_field = yes

# sequence_name - If we're using a sequence (Oracle, Postgres) this is
# the name to use.

#sequence_name   = [% package_name %]_seq

# is_secure - 'yes' if the object is protected by security, anything
# else if not

#is_secure       = yes

# no_insert - Fields for which we should not try to insert
# information, ever. If you're using a SPOPS implementation (e.g.,
# 'SPOPS::DBI::MySQL') which generates primary key values for you, be
# sure to put your 'id_field' value here.

#no_insert       = [% package_name %]_id

# no_update - Fields we should never update

#no_update       = [% package_name %]_id

# skip_undef - Values for these fields will not be inserted/updated at
# all if the value within the object is undefined. This, along with
# 'sql_defaults', allows you to specify default values. 

#skip_undef      =

# sql_defaults - List fields for which a default is defined. Note that
# SPOPS::DBI will re-fetch the object after first creating it if you
# have fields listed here to ensure that the object always reflects
# what's in the database.

#sql_defaults    =

# base_table - Name of the table we store the object information
# in. Note that if you have 'db_owner' defined in your application's
# 'server.perl' file (in the 'db_info' key), then SPOPS will prepend
# that (along with a period) to the table name here. For instance, if
# the db_owner is defined to 'dbo', we would use the table name
# 'dbo.[% package_name %]'

#base_table      = [% package_name %]

# alias - Additional aliases to use for referring to this object
# class. For instance, if we put 'project_[% package_name %]' here we'd be able to
# retrieve this class name by using 'CTX->lookup_object( '[% package_name %] )'
# AND 'CTX->lookup_object( 'project_[% package_name %]' ).

#alias           = 

# name - Either a field name or some other method name called on your
# object to generate a name for a particular object.

#name            =

# object_name - Name of this class of objects

#object_name     = [% class_name %]

# is_searchable = 'yes' if you'd like this object to be indexed by the
# full_text package.

# is_searchable = no

# fulltext_field - if you've set 'is_searchable' to 'yes' you'll need
# to list one or more fields of your object from which to pull text to
# index

# fulltext_field = 


# has_a - Define a 'has-a' relationship between objects from this
# class and any number of other objects. Each key in the hashref is an
# object class (which gets translated to your app's class when you
# apply the package to an application) and the value is an arrayref of
# field names. The field name determines the name of the routine
# created: if the field name matches up with the 'id_field' of that
# class, then we create a subroutine named for the object's
# 'object-alias' field. If the field name does not match, we append
# '_{object_alias}' to the end of the field. (See 'perldoc
# SPOPS::Manual::Relationships' for more.)

#[[% package_name %] has_a]
#OpenInteract2::Theme = theme_id

# links_to - Define a 'links-to' relationship between objects from
# this class and any number of other objects. This may be modified
# soon -- see 'perldoc SPOPS::Configure::DBI' for more.

#[[% package_name %] links_to]
#OpenInteract2::Foo = foo_[% package_name %]_link

# creation_security - Determine the security to apply to newly created
# objects from this class. (See 'SPOPS::Secure')

#[[% package_name %] creation_security]
#user  = WRITE
#group = site_admin_group:WRITE
#world = READ

# track - Which actions should we log? Value of 'yes' does, anything
# else does not.

#[[% package_name %] track]
#create = no
#update = yes
#remove = yes

# display - Allow the object to be able to generate a URL to display
# itself. OI2 has hooks so that you can refer to an ACTION and TASK
# and have OI2::URL use these to create a local URL, properly
# localized to your deployment context:

#[[% package_name %] display]
#ACTION = [% package_name %]
#TASK   = display

