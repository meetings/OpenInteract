.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Manage 3"
.TH OpenInteract2::Manage 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Manage \- Provide common functions and factory for management tasks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # Common programmatic use of management task:
\& 
\& use strict;
\& use OpenInteract2::Manage;
\& 
\& my $task = OpenInteract2::Manage\->new(
\&                    \*(Aqinstall_package\*(Aq,
\&                    { filename    => \*(Aq/home/httpd/site/uploads/file.tar.gz\*(Aq,
\&                      website_dir => \*(Aq/home/httpd/site\*(Aq } );
\& my @status = eval { $task\->execute };
\& if ( $@ ) {
\&     if ( $@\->isa( \*(AqOpenInteract2::Exception::Parameter\*(Aq ) ) {
\&         my $failures = $@\->parameter_fail;
\&         while ( my ( $field, $reasons ) = each %{ $failures } ) {
\&             print "Field $field: ", join( ", ", @{ $reasons } ), "\en";
\&         }
\&     }
\&     exit;
\& }
\& 
\& foreach my $s ( @status ) {
\&     print "Status: ", ( $s\->{is_ok} eq \*(Aqyes\*(Aq ) ? \*(AqOK\*(Aq : \*(AqNOT OK\*(Aq;
\&     print "\en$s\->{message}\en";
\& }
\& 
\& # Every task needs to implement the following:
\& 
\& sub run_task         {}
\& sub get_parameters   {} # if it has parameters
\& 
\& # The task can implement this to initialize the object
\& 
\& sub init             {}
\& 
\& # The task can also implement these for setting up/clearing out the
\& # environment
\& 
\& sub setup_task       {}
\& sub tear_down_task   {}
\& 
\& # The task can also implement this for checking/validating parameters
\& 
\& sub validate_param    {}
\& 
\& # This task is strongly advised to implement this to let the outside
\& # world know about its purpose
\& 
\& sub get_brief_description {}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
First, most people don't really care about this class. You'll use the
\&\f(CW\*(C`oi2_manage\*(C'\fR front-end to this set of tasks, so you probably want to
look there if you're itching to do something quickly.
.PP
OpenInteract2::Manage is the organizer,
interface and factory for tasks managing OpenInteract2. Its goal is to
make these tasks runnable from anywhere, not just the command-line,
and to provide output that can be parsed in a sufficiently generic
format to be useful anywhere.
.PP
Since it is an organizing module it does not actually perform the
tasks. You will want to see
OpenInteract2::Manage::Package or
OpenInteract2::Manage::Website to get
closer to that metal. You can also subclass this class directly, but
look first into the other subclasses as they may provide functionality
to make your task easier to implement.
.PP
If you're interested in subclassing you should really read
OpenInteract2::Manual::Management. It
was written just for \fByou\fR!
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\&\fBnew( \f(CB$task_name\fB, [ \e%params, ], [ \f(CB@extra_params\fB ]  )\fR
.PP
Creates a new management task of type \f(CW$task_name\fR. If type
\&\f(CW$task_name\fR is not yet registered, the method throws an exception.
.PP
You can also pass any number of \f(CW\*(C`\e%params\*(C'\fR with which the management
task gets initialized (using \f(CW\*(C`init()\*(C'\fR, below). These are blindly set
and not checked until you run \f(CW\*(C`execute()\*(C'\fR.
.PP
All of the \f(CW\*(C`extra_params\*(C'\fR are passed to \f(CW\*(C`init()\*(C'\fR, which subclasses
may implement to do any additional initialization.
.PP
Returns: New management task object
.PP
\&\fBis_valid_task( \f(CB$task_name\fB )\fR
.PP
Returns: true if \f(CW$task_name\fR is a valid task, false if not.
.PP
\&\fB\f(BIvalid_tasks()\fB\fR
.PP
Query the class about what tasks are currently registered.
.PP
Returns: list of registered tasks
.PP
\&\fB\f(BIvalid_tasks_description()\fB\fR
.PP
Query the class about what tasks are currently registered, plus get a
brief description of each.
.PP
Returns: hashref of registered tasks (keys) and their descriptions
(values).
.PP
\&\fBtask_parameters( [ \f(CB$task_name\fB ] )\fR
.PP
Ask the task for \f(CW$task_name\fR what its parameters are. Note that you
can use this as an object method as well, skipping the \f(CW$task_name\fR
parameter.
.PP
Returns: hashref with keys as parameter names and values as hashrefs
with the following data:
.IP "\fBname\fR" 4
.IX Item "name"
Parameter name
.IP "\fBdescription\fR" 4
.IX Item "description"
Description of this parameter for this task
.IP "\fBis_required\fR" 4
.IX Item "is_required"
Set to 'yes' if the parameter is required for operation
.IP "\fBis_boolean\fR" 4
.IX Item "is_boolean"
Set to 'yes' if it's a toggled parameter
.IP "\fBis_multivalued\fR" 4
.IX Item "is_multivalued"
Set to 'yes' if the parameter can handle multiple values
.IP "\fBdefault\fR" 4
.IX Item "default"
Set to the default value for this parameter
.PP
\&\fB\f(BIall_parameters()\fB\fR
.PP
Find all parameters used by all registered tasks and get the same data
.PP
used in \f(CW\*(C`task_parameters\*(C'\fR for each. The only change is that the
\&'description' key is not available since there's no task
context. (That is, 'website_dir' may have one meaning in one task but
another slightly different one in another.)
.PP
Returns: hashref with parameter names as keys and values the hashrefs
described in \f(CW\*(C`task_parameters\*(C'\fR except with no 'description' key.
.PP
\&\fB\f(BIall_parameters_long_options()\fB\fR
.PP
Shortcut for \s-1CLI\s0 programs (like \f(CW\*(C`oi2_manage\*(C'\fR...) that use
Getopt::Long. Returns an array of option specifiers
that you can send directly to the \f(CW\*(C`GetOptions( \e%, @ )\*(C'\fR
signature. For instance, say that from \f(CW\*(C`all_parameters()\*(C'\fR we get that
\&'website_dir' is a normal (non-boolean, non-multivalue) parameter. Its
entry would look like this:
.PP
.Vb 1
\& website_dir=s
.Ve
.PP
A parameter 'analyze' with 'is_boolean' set to 'yes' would simply be:
.PP
.Vb 1
\& analyze
.Ve
.PP
And a parameter 'package' with 'is_multivialued' set to 'yes' would
be:
.PP
.Vb 1
\& package=s@
.Ve
.PP
Returns: list of option specifiers compatible with
Getopt::Long.
.PP
\&\f(CW\*(C`find_management_tasks( @directories )\*(C'\fR
.PP
Find all management tasks under directories in \f(CW@directories\fR and
\&\f(CW\*(C`require\*(C'\fR them. Note that when this class is included it runs this
for every directory in \f(CW@INC\fR, so you should only need to run it if
you add directories to \f(CW@INC\fR (using \f(CW\*(C`use lib\*(C'\fR or manually).
.PP
Returns: nothing
.SS "Object Methods"
.IX Subsection "Object Methods"
\&\fB\f(BIexecute()\fB\fR
.PP
Runs through the methods \f(CW\*(C`check_parameters()\*(C'\fR, \f(CW\*(C`setup_task()\*(C'\fR,
\&\f(CW\*(C`run_task()\*(C'\fR, \f(CW\*(C`tear_down_task()\*(C'\fR.
.PP
Any of these methods can throw an exception, so it is up to you to
wrap the call to \f(CW\*(C`execute()\*(C'\fR in an \f(CW\*(C`eval\*(C'\fR block and examine \f(CW$@\fR.
.PP
Returns: an arrayref of status hash references. These should include
the keys 'is_ok' (set to 'yes' if the item succeeded, 'no' if not) and
\&'message' describing the results. Tasks may set additional items as
well, all of which should be documented in the task.
.PP
You can also retrieve the status messages by calling \f(CW\*(C`get_status()\*(C'\fR.
.PP
\&\fBparam( \f(CB$key\fB, \f(CB$value\fB )\fR
.PP
See OpenInteract2::ParamContainer for details.
.PP
Example:
.PP
.Vb 3
\& $task\->param( \*(Aqwebsite_dir\*(Aq, \*(Aq/home/httpd/test\*(Aq );
\& $task\->param( package => [ \*(Aqpkg1\*(Aq, \*(Aqpkg2\*(Aq ] );
\& my $all_params = $task\->param;
.Ve
.PP
Another way of setting parameters is by passing them into the
constructor. The second argument (hashref) passed into the \f(CW\*(C`new()\*(C'\fR
call can be set to the parameters you want to use for the task. This
makes it simple to do initialization and execution in one step:
.PP
.Vb 3
\& my @status = OpenInteract2::Manage\->new( \*(Aqcreate_website\*(Aq,
\&                                          { website_dir  => \*(Aq/home/httpd/test\*(Aq } )
\&                                   \->execute();
.Ve
.PP
\&\fBparam_copy_from( \f(CB$other_task\fB )\fR
.PP
Copy all parameters from \f(CW$other_task\fR into this object.
.PP
Returns: results of \f(CW\*(C`param()\*(C'\fR on this object after the copy
.PP
\&\fB\f(BIget_status()\fB\fR
.PP
Returns a list of all status messages. This won't be populated until
after you run \f(CW\*(C`execute()\*(C'\fR.
.SH "VALIDATING PARAMETERS"
.IX Header "VALIDATING PARAMETERS"
Every management task should be initialized with parameters that tell
the task how or where to perform its work. This parent class provides
the means to ensure required parameters are defined and that they are
valid. This parameter checking is very flexible so it is simple to
define your own validation checks and tell them to this parent class.
.SS "Checking Parameters: Flow"
.IX Subsection "Checking Parameters: Flow"
The management class has a fairly simple but flexible way for you to
ensure that your task gets valid parameters.
.PP
First, you can ensure that all the parameters required are defined by
the task caller. Just tag Simply create a method \f(CW\*(C`list_param_required()\*(C'\fR which
returns an arrayref of parameters that require a value to be defined:
.PP
\&\s-1TODO:\s0 Get rid of me
.PP
.Vb 1
\& sub list_param_required { return [ \*(Aqwebsite_dir\*(Aq, \*(Aqpackage_dir\*(Aq ] }
.Ve
.PP
You can also override the method \f(CW\*(C`check_required_parameters()\*(C'\fR, but
this requires you to throw the exceptions yourself.
.PP
Next, you need to ensure that all the parameters are valid. There are a couple of ways to do this
.SS "Checking Parameters: Methods"
.IX Subsection "Checking Parameters: Methods"
\&\fB\f(BIcheck_parameters()\fB\fR
.PP
This method is a wrapper for a number of separate jobs: parameter
initialization, required parameter checking and parameter validation.
.PP
It is called from \f(CW\*(C`execute()\*(C'\fR before \f(CW\*(C`run_task()\*(C'\fR is called, so any
initialization done there (like creating a
OpenInteract2::Context) hasn't been done
yet. This may force some tasks to put off validating some parameters
until \f(CW\*(C`run_task()\*(C'\fR. That's an acceptable behavior for now.
.PP
It uses the 'is_required' and 'do_validate' keys of the parameter
metadata passed back from \f(CW\*(C`get_parameters()\*(C'\fR.
.PP
The first action it performs is to call \f(CW\*(C`param_initialize()\*(C'\fR so your
task can do any necessary parameter manipulation.
.PP
Next it checks the required parameters, which cycling through the
parameters flagged with 'is_required' and ensuring that a value for
each parameter exists.
.PP
Finally it validates parameters, ensuring that parameters requiring
validation (those with 'is_required' or 'do_validate' toggled on) are
valid.
.PP
Any errors thrown by these methods are percolated up back to the
caller. Barring strange runtime errors they're going to be
OpenInteract2::Exception::Parameter
objects, which means the caller can do a filter as needed, displaying
more pertient information:
.PP
.Vb 10
\& eval { $task\->execute }
\& my $error = $@;;
\& if ( $error ) {
\&     if ( $error\->isa( \*(AqOpenInteract2::Exception::Parameter\*(Aq ) ) {
\&         print "Caught an exception with one or more paramters:\en";
\&         my $failed = $error\->parameter_fail;
\&         while ( my ( $field, $fail ) = each %{ $failed } ) {
\&             my @failures = ( ref $fail eq \*(AqARRAY\*(Aq ) ? @{ $fail } : ( $fail );
\&             foreach my $failure ( @failures ) {
\&                 print sprintf( "%\-20s\-> %s\en", $field, $failure );
\&             }
\&         }
\&     }
\&     else {
\&         print "Caught an error: $@";
\&     }
\& }
.Ve
.PP
\&\fB\f(BIparam_initialize()\fB\fR
.PP
This class implements this method to massage the 'package' parameter
into a consistent format.
.PP
You may want to implement it to modify your parameters before any
checking or validation. For instance, tasks dealing with packages
typically allow you to pass in a list or a comma-separated string, or
even use a keyword to represent multiple packages. The
\&\f(CW\*(C`param_initialize()\*(C'\fR method can change each of these into a
consistent format, allowing the task to assume it will always be
dealing with an arrayref. This is done at initialization. (You don't
have to do this, it's just an example.)
.PP
\&\f(CW\*(C`validate_param( $param_name, $param_value )\*(C'\fR
.PP
If \f(CW$param_name\fR with \f(CW$param_value\fR is valid return nothing,
otherwise return one or more error messages in a list. If you're a
subclass you should forward the request onto your parents via
\&\f(CW\*(C`SUPER\*(C'\fR. See examples of this in
OpenInteract2::Manual::Management.
.SH "OBSERVERS"
.IX Header "OBSERVERS"
Every management task is observable. (See
Class::Observable for what this means.) As a
creator and user of a task you can add your own observers to it and
receive status and progress messages from the task as it performs its
work.
.PP
There are two types of standard observations posted from management
tasks. This type is passed as the first argument to your observer.
.IP "\(bu" 4
\&\fBstatus\fR: This is a normal status message. (See \*(L"\s-1STATUS\s0 \s-1MESSAGES\s0\*(R"
for what this means.) The second argument passed to your observer will
be the hashref representing the status message.
.IP "\(bu" 4
\&\fBprogress\fR: Indicates a new stage of the process has been reached or
completed. The second argument to your observer is a text message, the
optional third argument is a hashref of additional
information. Currently this has only one option: \fBlong\fR may be set to
\&'yes', and if so the task is telling you it's about to begin a
long-running process.
.PP
For an example of an observer, see \f(CW\*(C`oi2_manage\*(C'\fR.
.SH "STATUS MESSAGES"
.IX Header "STATUS MESSAGES"
Status messages are simple hashrefs with at least three entries:
.IP "\(bu" 4
\&\fBis_ok\fR: Set to 'yes' if this a successful status, 'no' if not.
.IP "\(bu" 4
\&\fBaction\fR: Name of the action.
.IP "\(bu" 4
\&\fBmessage\fR: Message describing the action or the error encountered.
.PP
Each message may have any number of additional entries. A common one
is \fBfilename\fR, which is used to indicate the file acted upon. Every
management task should list what keys its status messages support, not
including the three listed above.
.PP
Some tasks can generate a lot of status messages, so the method
\&\f(CW\*(C`merge_status_by_action\*(C'\fR will merge all status messages with the same
\&\f(CW\*(C`action\*(C'\fR into a single message with the keys \f(CW\*(C`action\*(C'\fR (the action)
and \f(CW\*(C`status\*(C'\fR (an arrayref of the collected status messages under that
action).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
OpenInteract2::Manual::Management
.PP
Class::Factory
.PP
OpenInteract2::Manage::Package
.PP
OpenInteract2::Manage::Website
.PP
OpenInteract2::Setup
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
