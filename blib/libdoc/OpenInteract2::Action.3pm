.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Action 3"
.TH OpenInteract2::Action 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Action \- Represent and dispatch actions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& # Define an action in configuration to have its content generated by
\& # the TT generator (Template Toolkit) and security
\& # checked. (Previously you had to subclass SPOPS::Secure.)
\& 
\& [news]
\& class             = OpenInteract2::Action::News
\& is_secure         = yes
\& content_generator = TT
\& 
\& # The tasks \*(Aqlisting\*(Aq, \*(Aqlatest\*(Aq and \*(Aqdisplay\*(Aq can be cached, for 90
\& # seconds, 10 minutes, and 1 day, respectively.
\& 
\& [news cache_expire]
\& listing           = 90
\& latest            = 10m
\& display           = 1d
\& 
\& # Cached content depends on these parameters (multiple ok)
\& 
\& [news cache_param]
\& listing           = num_items
\& listing           = language
\& latest            = num_items
\& display           = news_id
\& 
\& # You can declare security levels in the action configuration, or you
\& # can override the method _find_security_level()
\& 
\& [news security]
\& default           = write
\& display           = read
\& listing           = read
\& latest            = read
\& 
\& # Same handler class, but mapped to a different action and with an
\& # extra parameter, and the \*(Aqedit\*(Aq and \*(Aqremove\*(Aq tasks are marked as
\& # invalid.
\& 
\& [newsuk]
\& class             = OpenInteract2::Action::News
\& is_secure         = no
\& news_from         = uk
\& content_generator = TT
\& task_invalid      = edit
\& task_invalid      = remove
\& 
\& [newsuk cache_expire]
\& listing           = 10m
\& latest            = 300
\& 
\& # Future: Use the same code to generate a SOAP response; at server
\& # startup this should setup SOAP::Lite to respond to a request at
\& # the URL \*(Aq/SoapNews\*(Aq.
\& 
\& [news_rpc]
\& class             = OpenInteract2::Action::News
\& is_secure         = yes
\& content_generator = SOAP
\& url               = SoapNews
\& 
\& [news_rpc cache_expire]
\& listing           = 10m
\& latest            = 300
\& 
\& [news_rpc security]
\& default           = write
\& display           = read
\& 
\& # Dispatch a request to the action by looking up the action in the
\& # OpenInteract2::Context object:
\& 
\& # ...using the default task
\& my $action = CTX\->lookup_action( \*(Aqnews\*(Aq );
\& return $action\->execute;
\& 
\& # ...specifying a task
\& my $action = CTX\->lookup_action( \*(Aqnews\*(Aq );
\& $action\->task( \*(Aqdisplay\*(Aq );
\& return $action\->execute;
\& 
\& # ...specifying a task and passing parameters
\& my $action = CTX\->lookup_action( \*(Aqnews\*(Aq );
\& $action\->task( \*(Aqdisplay\*(Aq );
\& $action\->param( news => $news );
\& $action\->param( grafs => 3 );
\& return $action\->execute;
\& 
\& # Dispatch a request to the action by manually creating an action
\& # object
\& 
\& # ...using the default task
\& my $action = OpenInteract2::Action\->new( \*(Aqnews\*(Aq );
\& 
\& # ...specifying a task
\& my $action = OpenInteract2::Action\->new( \*(Aqnews\*(Aq, { task => \*(Aqdisplay\*(Aq } );
\& 
\& # ...specifying a task and passing parameters
\& my $action = OpenInteract2::Action\->new( \*(Aqnews\*(Aq,
\&                                         { task  => \*(Aqdisplay\*(Aq,
\&                                           news  => $news,
\&                                           grafs => 3 } );
\& 
\& # Set parameters after the action has been created
\& $action\->param( news  => $news );
\& $action\->param( grafs => 3 );
\& 
\& # Run the action and return the content
\& return $action\->execute;
\&
\& # IN AN ACTION
\& 
\& sub change_some_object {
\&     my ( $self ) = @_;
\&     # ... do the changes ...
\& 
\&     # Clear out cache entries for this action so we don\*(Aqt have stale
\&     # content being served up
\& 
\&     $self\->clear_cache;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Action object is a core piece of the OpenInteract framework. Every
component in the system and part of an application is represented by
an action. An action always returns content from its primary
interface, the \f(CW\*(C`execute()\*(C'\fR method. This content can be built by the
action directly, constructed by passing parameters to a content
generator, or passed off to another action for generation. (See
\&\*(L"\s-1GENERATING\s0 \s-1CONTENT\s0 \s-1FOR\s0 \s-1ACTION\s0\*(R" below.)
.SS "Action Class Initialization"
.IX Subsection "Action Class Initialization"
When OpenInteract starts up it will call \f(CW\*(C`init_at_startup()\*(C'\fR on every
configured action class. (The class
OpenInteract2::Setup::InitializeActions actually does this.) This
is useful for reading static (or rarely changing) information once and
caching the results. Since the OpenInteract2::Context object is
guaranteed to have been created when this is called you can grab a
database handle and slurp all the lookup entries from a table into a
lexical data structure.
.PP
Here is an example:
.PP
.Vb 2
\& use Log::Log4perl            qw( get_logger );
\& use OpenInteract2::Context   qw( CTX );
\& 
\& # Publishers don\*(Aqt change very often, so keep them local so we don\*(Aqt
\& # have to fetch every time
\& 
\& my %publishers = ();
\& 
\& ...
\& 
\& sub init_at_startup {
\&     my ( $class ) = @_;
\&     $log ||= get_logger( LOG_APP );
\&     my $publisher_list = eval {
\&         CTX\->lookup_object( \*(Aqpublisher\*(Aq )\->fetch_group()
\&     };
\&     if ( $@ ) {
\&         $log\->error( "Failed to fetch publishers at startup: $@" );
\&     }
\&     else {
\&         foreach my $publisher ( @{ $publisher_list } ) {
\&             $publishers{ $publisher\->name } = $publisher;
\&         }
\&     }
\& }
.Ve
.SS "Action Tasks"
.IX Subsection "Action Tasks"
Each action can be viewed as an associated collection of
tasks. Generally, each task maps to a subroutine in the package of the
action. For instance, the following package defines three tasks that
all operate on 'news' objects:
.PP
.Vb 1
\& package My::News;
\& 
\& use strict;
\& use base qw( OpenInteract2::Action );
\& 
\& sub latest  { return "Lots of news in the last week" }
\& sub display { return "This is the display task!" }
\& sub add     { return "Adding..." }
\& 
\& 1;
.Ve
.PP
Here is how you would call them, assuming that this action is mapped
to the 'news' key:
.PP
.Vb 4
\& my $action = CTX\->lookup_action( \*(Aqnews\*(Aq );
\& $action\->task( \*(Aqlatest\*(Aq );
\& print $action\->execute;
\& # Lots of news in the last week
\& 
\& $action\->task( \*(Aqdisplay\*(Aq );
\& print $action\->execute;
\& # This is the display task!
\& 
\& $action\->task( \*(Aqadd\*(Aq );
\& print $action\->execute;
\& # Adding...
.Ve
.PP
You can also create your own dispatcher by defining the method
\&'handler' in your action class. For instance:
.PP
\&\s-1TODO:\s0 This won't work, will it? Won't we just keep calling 'handler'
again and again?
.PP
.Vb 1
\& package My::News;
\& 
\& use strict;
\& use base qw( OpenInteract2::Action );
\& 
\& sub handler {
\&     my ( $self ) = @_;
\&     my $task = $self\->task;
\&     my $language = CTX\->user\->language;
\&     my ( $new_task );
\&     if ( $task eq \*(Aqlist\*(Aq and $language eq \*(Aqes\*(Aq ) {
\&         $new_task = \*(Aqlist_spanish\*(Aq;
\&     }
\&     elsif ( $task eq \*(Aqlist\*(Aq and $language eq \*(Aqru\*(Aq ) {
\&         $new_task = \*(Aqlist_russian\*(Aq;
\&     }
\&     elsif ( $task eq \*(Aqlist\*(Aq ) {
\&         $new_task = \*(Aqlist_english\*(Aq;
\&     }
\&     else {
\&         $new_task = $task;
\&     }
\&     return $self\->execute({ task => $new_task });
\& }
\& 
\& sub list_spanish { return "Lots of spanish news in the last week" }
\& sub list_russian { return "Lots of russian news in the last week" }
\& sub list_english { return "Lots of english news in the last week" }
\& sub display { return "This is the display task!" }
\& sub edit { return "Editing..." }
\& 
\& 1;
.Ve
.PP
You have control over whether a subroutine in your action class is
exposed as a task. The following tasks will never be run:
.IP "\(bu" 4
Tasks beginning with an underscore.
.IP "\(bu" 4
Tasks listed in the \f(CW\*(C`task_invalid\*(C'\fR property.
.PP
Additionally, if you have defined the \f(CW\*(C`task_valid\*(C'\fR property then only
those tasks will be valid. All others will be forbidden.
.PP
To use our example above, assume we have configured the action with
the following:
.PP
.Vb 4
\& [news]
\& class        = OpenInteract2::Action::News
\& task_valid   = latest
\& task_valid   = display
.Ve
.PP
Then the 'add' task will not be valid. You could also explicitly
forbid the 'add' task from being executed with:
.PP
.Vb 3
\& [news]
\& class        = OpenInteract2::Action::News
\& task_invalid = add
.Ve
.PP
See discussion of \f(CW\*(C`_find_task()\*(C'\fR and \f(CW\*(C`_check_task_validity()\*(C'\fR for more
information.
.SS "Action Types"
.IX Subsection "Action Types"
An action type implements one or more public methods in a sufficiently
generic fashion as to be applicable to different applications. Actions
implemented using action types normally do not need any code: the
action type relies on configuration information and/or parameters to
perform its functions.
.PP
To use an action type, you just need to specify it in your
configuration:
.PP
.Vb 3
\& [foo]
\& action_type  = lookup
\& ...
.Ve
.PP
Each action type has configuration entries it uses. Here's what the
full declaration for a lookup action might be:
.PP
.Vb 12
\& [foo]
\& action_type  = lookup
\& object_key   = foo
\& title        = Foo Listing
\& field_list   = foo
\& field_list   = bar
\& label_list   = A Foo
\& label_list   = A Bar
\& size_list    = 25
\& size_list    = 10
\& order        = foo
\& url_none     = yes
.Ve
.PP
Action types are declared in the server configuration under the
\&'action_types' key. \s-1OI2\s0 ships with:
.PP
.Vb 3
\& [action_types]
\& template_only = OpenInteract2::Action::TemplateOnly
\& lookup        = OpenInteract2::Action::LookupEdit
.Ve
.PP
If you'd like to add your own type you just need to add the name and
class to the list. It will be picked up at the next server start. You
can also add them programmatically using \f(CW\*(C`register_factory_type()\*(C'\fR
(inherited from Class::Factory):
.PP
.Vb 1
\& OpenInteract2::Action\->register_factory_type( mytype => \*(AqMy::Action::Type\*(Aq );
.Ve
.SS "Action Properties vs. Parameters"
.IX Subsection "Action Properties vs. Parameters"
\&\fBAction Properties\fR are found in every action. These represent
standard information about the action: name, task, security
information, etc. All properties are described in \s-1PROPERTIES\s0.
.PP
\&\fBAction Parameters\fR are extra information attached to the
action. These are analogous in OpenInteract 1.x to the hashref passed
into a handler as the second argument. For instance:
.PP
.Vb 1
\& # OpenInteract 1.x
\& 
\& return $class\->display({ object     => $foo,
\&                          error_msg  => $error_msg,
\&                          status_msg => $status_msg });
\& 
\& sub display {
\&     my ( $class, $params ) = @_;
\&     if ( $params\->{error_msg} ) {
\&         return $R\->template\->handler( {}, $params,
\&                                       { name => \*(Aqmypkg::error_page\*(Aq } );
\&     }
\& }
\&
\& # OpenInteract 2.x
\& 
\& $action\->task( \*(Aqdisplay\*(Aq );
\& $action\->param( object => $foo );
\& $action\->param_add( error_msg => $error_msg );
\& $action\->param_add( status_msg => $status_msg );
\& return $action\->execute;
\& 
\& # also: assign parameters in one call
\& 
\& $action\->task( \*(Aqdisplay\*(Aq );
\& $action\->param_assign({ object     => $foo,
\&                         error_msg  => $error_msg,
\&                         status_msg => $status_msg });
\& return $action\->execute;
\& 
\& # also: pass parameters in last statement
\& 
\& $action\->task( \*(Aqdisplay\*(Aq );
\& return $action\->execute({ object     => $foo,
\&                           error_msg  => $error_msg,
\&                           status_msg => $status_msg });
\& 
\& # also: pass parameters plus a property in last statement
\& 
\& return $action\->execute({ object     => $foo,
\&                           error_msg  => $error_msg,
\&                           status_msg => $status_msg,
\&                           task       => \*(Aqdisplay\*(Aq });
\& 
\& sub display {
\&     my ( $self ) = @_;
\&     if ( $self\->param( \*(Aqerror_msg\*(Aq ) ) {
\&         return $self\->generate_content(
\&                              {}, { name => \*(Aqmypkg::error_page\*(Aq } );
\&     }
\& }
.Ve
.SH "OBSERVABLE ACTIONS"
.IX Header "OBSERVABLE ACTIONS"
.SS "What does it mean?"
.IX Subsection "What does it mean?"
All actions are \fBobservable\fR. This means that any number of classes,
objects or subroutines can register themselves with an action class
(or a specific action instance) and be activated when that action
publishes a notification. It is a great way to decouple an object from
other functions that want to operate on the results of that
object. The observed object (in this case, the action) does not know
how many observers there are, or even if any exist at all.
.SS "Observable Scenario"
.IX Subsection "Observable Scenario"
That is all very abstract, so here is a scenario:
.PP
\&\fBExisting action\fR: Register a new user
.PP
\&\fBNotification published\fR: When new user confirms registration.
.PP
\&\fBDesired outcome\fR: Add the user name and email address to various
services within the website network. This is done via an asynchronous
message published to each site in the network. The network names are
stored in a server configuration variable 'network_queue_server'.
.PP
How to implement:
.PP
.Vb 1
\& package OpenInteract2::Observer::NewUserPublish;
\& 
\& use strict;
\& 
\& sub update {
\&     my ( $class, $action, $notify_type, $user ) = @_;
\&     if ( $notify_type eq \*(Aqregister\-confirm\*(Aq ) {
\&         my $user = $action\->param( \*(Aquser\*(Aq );
\&         my $network_servers = CTX\->server_config\->{network_queue_server};
\&         foreach my $server_name ( @{ $network_servers } ) {
\&             my $server = CTX\->queue_connect( $server_name );
\&             $server\->publish( \*(Aqnew user\*(Aq, $user );
\&         }
\&     }
\& }
.Ve
.PP
You would register this observer in \f(CW\*(C`$WEBSITE_DIR/conf/observer.ini\*(C'\fR
like this:
.PP
.Vb 2
\& [observer]
\& newuserpublish = OpenInteract2::Observer::NewUserPublish
.Ve
.PP
And the action would notify all observers like this:
.PP
.Vb 1
\& package OpenInteract2::Action::NewUser;
\& 
\& # ... other methods here ...
\& 
\& sub confirm_registration {
\&     my ( $self ) = @_;
\&     my $user = create_user_object_somehow( ... );
\&
\&     # ... check registration ...
\&     if ( $registration_ok ) {
\&
\&         # This notifies all observers of the \*(Aqregister\-confirm\*(Aq event
\&
\&         $self\->notify_observers( \*(Aqregister\-confirm\*(Aq, $user );
\&         return $self\->generate_content(
\&                        {}, { name => \*(Aqbase_user::newuser_confirm_ok\*(Aq } );
\&     }
\& }
.Ve
.PP
In the same \f(CW\*(C`observer.ini\*(C'\fR file you registered the observer you would
map the observer to the action (assuming the action is named
\&'newuser'):
.PP
.Vb 2
\& [observer action]
\& newuserpublish = newuser
.Ve
.PP
Finally, in the documentation for the package 'base_user' (since the
\&'newuser' action lives there), you would have information about what
notifications are published by the \f(CW\*(C`OpenInteract2::Action::NewUser\*(C'\fR
action so other observers could register themselves.
.SS "Built-in Observations"
.IX Subsection "Built-in Observations"
\&\fBfilter\fR
.PP
Filters can register themselves as observers and get passed a
reference to content. A filter can transform the content in any manner
it requires. The observation is posted just before the content is
cached, so if the content is cacheable any modifications will become
part of the cache. (If you need to filter the cached content watch for
the observation 'cache hit'; it also posts a scalar reference of the
content.)
.PP
Here is an example:
.PP
.Vb 1
\& package OpenInteract2::WikiFilter;
\& 
\& use strict;
\& 
\& sub update {
\&     my ( $class, $action, $type, $content ) = @_;
\&     return unless ( $type eq \*(Aqfilter\*(Aq );
\& 
\&     # Note: $content is a scalar REFERENCE
\& 
\&     $class\->_transform_wiki_words( $content );
\& }
.Ve
.PP
Since a filter is just another type of observer you register them in
the same place, \f(CW\*(C`$WEBSITE_DIR/conf/observer.ini\*(C'\fR:
.PP
.Vb 2
\& [observer]
\& wiki = OpenInteract2::WikiFilter
.Ve
.PP
And then map the observer to one or more actions:
.PP
.Vb 3
\& [map]
\& wiki = news
\& wiki = page
.Ve
.PP
See OpenInteract2::Observer for more
information.
.PP
\&\fBpre/post common\fR
.PP
See the common actions for a number of observations they
publish. Generally, the actions fire an observation before they
perform their action and after:
.IP "\fBOpenInteract2::Action::CommonAdd\fR" 4
.IX Item "OpenInteract2::Action::CommonAdd"
Fires: 'pre add' and 'post add'
.IP "\fBOpenInteract2::Action::CommonUpdate\fR" 4
.IX Item "OpenInteract2::Action::CommonUpdate"
Fires: 'pre update' and 'post update'
.IP "\fBOpenInteract2::Action::CommonRemove\fR" 4
.IX Item "OpenInteract2::Action::CommonRemove"
Fires: 'pre remove' and 'post remove'
.SH "MAPPING URL TO ACTION"
.IX Header "MAPPING URL TO ACTION"
In \s-1OI\s0 1.x the name of an action determined what \s-1URL\s0 it responded
to. This was simple but inflexible. \s-1OI\s0 2.x gives you the option of
decoupling the name and \s-1URL\s0 and allowing each action to respond to
multiple URLs as well.
.PP
The default behavior is to respond to URLs generated from the action
name. Unlike \s-1OI\s0 1.x it is not strictly case-insensitive. It will
respond to URLs formed from:
.IP "\(bu" 4
Lowercasing the action name
.IP "\(bu" 4
Uppercasing the action name
.IP "\(bu" 4
Uppercasing the first letter of the action name, lowercasing the rest.
.PP
For example, this action:
.PP
.Vb 2
\& [news]
\& class = MyPackage::Action::News
.Ve
.PP
will respond to the following URLs:
.PP
.Vb 3
\& /news/
\& /NEWS/
\& /News/
.Ve
.PP
This default behavior can be modified and/or replaced by three
properties:
.IP "\(bu" 4
\&\fBurl\fR: Specify a single \s-1URL\s0 to which this action will respond. This
\&\fBreplaces\fR the default behavior.
.IP "\(bu" 4
\&\fBurl_none\fR: Tell \s-1OI\s0 that this action \fBcannot\fR be accessed via \s-1URL\s0,
appropriate for box or other template-only actions. This \fBreplaces\fR
the default behavior.
.IP "\(bu" 4
\&\fBurl_alt\fR: Specify a number of additional URLs to which this action
will respond. This \fBadds to\fR the default behavior, and may also be
used in conjunction with \fBurl\fR (but not \fBurl_none\fR).
.PP
Here are some examples to illustrate:
.PP
Use 'url' by itself:
.PP
.Vb 3
\& [news]
\& class = MyPackage::Action::News
\& url   = News
.Ve
.PP
Responds to:
.PP
.Vb 1
\& /News/
.Ve
.PP
Use 'url' with 'url_alt':
.PP
.Vb 5
\& [news]
\& class   = MyPackage::Action::News
\& url     = News
\& url_alt = Nouvelles
\& url_alt = Noticias
.Ve
.PP
Responds to:
.PP
.Vb 3
\& /News/
\& /Nouvelles/
\& /Noticias/
.Ve
.PP
Use default behavior with 'url_alt':
.PP
.Vb 4
\& [news]
\& class   = MyPackage::Action::News
\& url_alt = Nouvelles
\& url_alt = Noticias
.Ve
.PP
Responds to:
.PP
.Vb 5
\& /news/
\& /NEWS/
\& /News/
\& /Nouvelles/
\& /Noticias/
.Ve
.PP
Use 'url_none':
.PP
.Vb 4
\& [news_box]
\& class    = MyPackage::Action::News
\& method   = box
\& url_none = yes
.Ve
.PP
Responds to: nothing
.PP
Use 'url_none' with 'url_alt':
.PP
.Vb 5
\& [news_box]
\& class    = MyPackage::Action::News
\& method   = box
\& url_none = yes
\& url_alt  = NoticiasBox
.Ve
.PP
Responds to: nothing
.PP
The actual mapping of \s-1URL\s0 to Action is done in the
OpenInteract2::Context method
\&\f(CW\*(C`action_table()\*(C'\fR. Whenever the action table is assigned to the
context is iterates through the actions, asks each one which URLs it
responds to and creates a mapping so the \s-1URL\s0 can be quickly looked up.
.PP
One other thing to note about that context method: it also embeds the
\&\fBprimary\fR \s-1URL\s0 for each action in the information stored in the action
table. Since the information is stored in a key that is not a property
or parameter the action itself does not care about this. But it is
useful to note because when you generate URLs based on an action the
\&\fBfirst\fR \s-1URL\s0 is used, as discussed in the examples above.
.PP
So, to repeat the examples above, when you have:
.PP
.Vb 3
\& [news]
\& class = MyPackage::Action::News
\& url   = News
.Ve
.PP
The first \s-1URL\s0 will be:
.PP
.Vb 1
\& /News/
.Ve
.PP
When you have:
.PP
.Vb 5
\& [news]
\& class   = MyPackage::Action::News
\& url     = News
\& url_alt = Nouvelles
\& url_alt = Noticias
.Ve
.PP
The first \s-1URL\s0 will still be:
.PP
.Vb 1
\& /News/
.Ve
.PP
When you have:
.PP
.Vb 4
\& [news]
\& class   = MyPackage::Action::News
\& url_alt = Nouvelles
\& url_alt = Noticias
.Ve
.PP
The first \s-1URL\s0 will be:
.PP
.Vb 1
\& /news/
.Ve
.PP
because the default always puts the lowercased entry first.
.SH "GENERATING CONTENT FOR ACTION"
.IX Header "GENERATING CONTENT FOR ACTION"
Actions \fBalways\fR return content. That content might be what you
expect, it might be an error message, or it might be the result of
another action. Normally the content is generated by passing data to
some sort of template processor along with the template to use. The
template processor passes the data to the template and returns the
result. But there is nothing that says you cannot just manually return
a string :\-)
.PP
The template processor is known as a 'content generator', since it
does not need to use templates at all. OpenInteract maintains a list
of content generators, each of which has a class and method associated
with it. (You can grab a content generator from the
OpenInteract2::Context object using
\&\f(CW\*(C`get_content_generator()\*(C'\fR.)
.PP
Generally, your handler can just call \f(CW\*(C`generate_content()\*(C'\fR:
.PP
.Vb 11
\& sub display {
\&     my ( $self ) = @_;
\&     my $request = CTX\->request;
\&     my $news_id = $request\->param( \*(Aqnews_id\*(Aq );
\&     my $news_class = CTX\->lookup_object( \*(Aqnews\*(Aq );
\&     my $news = $news_class\->fetch( $news_id )
\&                || $news_class\->new();
\&     my %params = ( news => $news );
\&     return $self\->generate_content(
\&                         \e%params, { name => \*(Aqmypkg::error_page\*(Aq } );
\& }
.Ve
.PP
And not care about how the object will get displayed. So this action
could be declared in both of the following ways:
.PP
.Vb 3
\& [news]
\& class             = OpenInteract2::Action::News
\& content_generator = TT
\& 
\& [shownews]
\& class             = OpenInteract2::Action::News
\& task              = display
\& return_parameter  = news
\& content_generator = SOAP
.Ve
.PP
If the \s-1URL\s0 'http://foo/news/display/?news_id=45' comes in from a browser
we will pass the news object to the Template Toolkit generator which
will display the news object in some sort of \s-1HTML\s0 page.
.PP
However, if the \s-1URL\s0 'http://foo/news/shownews/' comes in via \s-1SOAP\s0,
with the parameter 'news_id' defined as '45', we will pass the same
news object off to the \s-1SOAP\s0 content generator, which will take the
\&'news' parameter and place it into a \s-1SOAP\s0 response.
.SS "Caching"
.IX Subsection "Caching"
Another useful feature that comes from having the content generated in
a central location is that your content can be cached
transparently. Caching is done entirely in actions but is sizable
enough to be documented elsewhere. Please see
OpenInteract2::Manual::Caching for
the lowdown.
.SH "PROPERTIES"
.IX Header "PROPERTIES"
You can set any of the properties with a method call. Examples are
given for each.
.PP
\&\fBrequest\fR (object)
.PP
\&\s-1TODO:\s0 May go away
.PP
The OpenInteract2::Request associated with
the current request.
.PP
\&\fBresponse\fR (object)
.PP
\&\s-1TODO:\s0 May go away
.PP
The OpenInteract2::Response associated with
the current response.
.PP
\&\fBname\fR ($)
.PP
The name of this action. This is normally used to lookup information
from the action table.
.PP
This property is read-only \*(-- it is set by the constructor when you
create a new action, but you cannot change it after the action is
created:
.PP
Example:
.PP
.Vb 1
\& print "Action name: ", $action\->name, "\en";
.Ve
.PP
\&\fBurl\fR ($)
.PP
\&\s-1URL\s0 used for this action. This is frequently the same as \fBname\fR, but
you can override it in the action configuration. Note that this is
\&\fBnot\fR the fully qualified \s-1URL\s0 \*(-- you need the \f(CW\*(C`create_url()\*(C'\fR method
for that.
.PP
This property is read-only \*(-- it is set by the constructor when you
create a new action, but you cannot change it after the action is
created:
.PP
Setting this property has implications as to what URLs your action
will respond to. See \*(L"\s-1MAPPING\s0 \s-1URL\s0 \s-1TO\s0 \s-1ACTION\s0\*(R" for more information.
.PP
Example:
.PP
.Vb 1
\& print "You requested ", $action\->url, " within the application."
.Ve
.PP
\&\fBurl_none\fR (bool)
.PP
Set to 'yes' to tell \s-1OI\s0 that you do not want this action accessible
via a \s-1URL\s0. This is often done for boxes and other template-only
actions. See \*(L"\s-1MAPPING\s0 \s-1URL\s0 \s-1TO\s0 \s-1ACTION\s0\*(R" for more information.
.PP
Example:
.PP
.Vb 6
\& [myaction]
\& class    = MyPackage::Action::MyBox
\& method   = box
\& title    = My Box
\& weight   = 5
\& url_none = yes
.Ve
.PP
\&\fBurl_alt\fR (\e@)
.PP
A number of other URLs this action can be accessible by. See \*(L"\s-1MAPPING\s0
\&\s-1URL\s0 \s-1TO\s0 \s-1ACTION\s0\*(R" for more information.
.PP
Example:
.PP
.Vb 4
\& [news]
\& class    = MyPackage::Action::News
\& url_alt  = Nouvelles
\& url_alt  = Noticias
.Ve
.PP
\&\fBurl_additional( \e@ or \e% )\fR
.PP
Action parameter names to associate with additional \s-1URL\s0 parameters
pulled from the request's \f(CW\*(C`param_url_additional()\*(C'\fR method. This
association is done in \f(CW\*(C`execute()\*(C'\fR.
.PP
If specified as an arrayref we associate the parameters no matter what
task is called on the action. If specified as a hashref you can
specify parameter names per-task, using \s-1DEFAULT\s0 as a catch-all.
.PP
Examples:
.PP
.Vb 5
\& # the value of the first additional URL parameter is assigned to the
\& # action parameter \*(Aqnews_id\*(Aq
\& [news]
\& ...
\& url_additional = news_id
\& 
\& # Given URL:
\& URL: http://foo/news/display/22/
\& 
\& # Task implementation
\& sub display {
\&     my ( $self ) = @_;
\&     my $id = $self\->param( \*(Aqnews_id\*(Aq );
\&     # $id is \*(Aq22\*(Aq since we pulled it from the first URL parameter
\& }
\&
\& # for all actions but \*(Aqarchive\*(Aq the value of the first additional URL
\& # parameter is assigned to the action parameter \*(Aqnews_id\*(Aq; for
\& # archive we assign them to \*(Aqsearch_year\*(Aq, \*(Aqsearch_month\*(Aq and
\& # \*(Aqsearch_day\*(Aq
\& [news]
\& ...
\& [news url_additional]
\& DEFAULT = news_id
\& archive = search_year
\& archive = search_month
\& archive = search_day
\& 
\& # Given URL:
\& http://foo/news/remove/1099/
\& 
\& # Task implementation matching \*(AqDEFAULT\*(Aq
\& sub remove {
\&     my ( $self ) = @_;
\&     my $id = $self\->param( \*(Aqnews_id\*(Aq );
\&     # $id is \*(Aq1099\*(Aq since we pulled it from the first URL parameter
\& }
\& 
\&  # Given URL:
\& http://foo/news/archive/2005/7/
\& 
\& sub archive {
\&     my ( $self ) = @_;
\&     my $year  = $self\->param( \*(Aqsearch_year\*(Aq );
\&     my $month = $self\->param( \*(Aqsearch_month\*(Aq );
\&     my $day   = $self\->param( \*(Aqsearch_day\*(Aq );
\&     # $year = 2005; $month = 7; $day is undef
\& }
.Ve
.PP
\&\fBmessage_name\fR ($)
.PP
Name used to find messages from the
OpenInteract2::Request object. Normally you
do not need to specify this and the action name is used. But if you
have multiple actions pointing to the same code this can be useful
.PP
Example:
.PP
.Vb 3
\& [news]
\& class        = MyPackage::Action::News
\& task_default = latest
\& 
\& [latestnews]
\& class        = MyPackage::Action::News
\& method       = latest
\& message_name = news
.Ve
.PP
\&\fBaction_type\fR ($)
.PP
The type of action this is. Action types can provide default tasks,
output filters, etc. This is not required.
.PP
Example:
.PP
.Vb 3
\& $action\->action_type( \*(Aqcommon\*(Aq );
\& $action\->action_type( \*(Aqdirectory_handler\*(Aq );
\& $action\->action_type( \*(Aqtemplate_only\*(Aq );
.Ve
.PP
See \*(L"Action Types\*(R" above for how to specify the action types actions
can use.
.PP
\&\fBtask\fR ($)
.PP
What task should this action run? Generally this maps to a subroutine
name, but the action can optionally provide its own dispatching
mechanism which maps the task in a different manner. (See Action
Tasks above for more information.)
.PP
Example:
.PP
.Vb 5
\& if ( $security_violation ) {
\&     $action\->param( error_msg => "Security violation: $security_violation" );
\&     $action\->task( \*(Aqsearch_form\*(Aq );
\&     return $action\->execute;
\& }
.Ve
.PP
\&\fBcontent_generator\fR ($)
.PP
Name of a content generator. Your server configuration can have a
number of content generators defined; this property should contain the
name of one.
.PP
Example:
.PP
.Vb 3
\& if ( $action\->content_generator eq \*(AqTT\*(Aq ) {
\&     print "Content for this action will be generated by the Template Toolkit.";
\& }
.Ve
.PP
The property is frequently inherited from the default action, so you
may not see it explicitly declared in the action table.
.PP
\&\fBtemplate_source\fR (\e%)
.PP
You have the option to specify your template source in the
configuration. This is required if using multiple content generators
for the same subroutine. (Actually, this is not true unless all your
content generators can understand the specified template source. This
will probably never happen given the sheer variety of templating
systems on the planet.)
.PP
This \fBwill not work\fR when an action superclass requires different
parameters to specify content templates. One set of examples are the
subclasses
OpenInteract2::Action::Common.
.PP
Example, not using 'template_source'. First the action configuration:
.PP
.Vb 3
\& [foo]
\& class = OpenInteract2::Action::Foo
\& content_generator = TT
.Ve
.PP
Now the action:
.PP
.Vb 6
\& sub mytask {
\&     my ( $self ) = @_;
\&     my %params = ( foo => \*(Aqbar\*(Aq, baz => [ \*(Aqthis\*(Aq, \*(Aqthat\*(Aq ] );
\&     return $self\->generate_content( \e%params,
\&                                     { name => \*(Aqfoo::mytask_template\*(Aq } );
\& }
.Ve
.PP
Example using 'template_source'. First the configuration:
.PP
.Vb 4
\& [foo]
\& class = OpenInteract2::Action::Foo
\& content_generator = TT
\& ...
\& 
\& [foo template_source]
\& mytask = foo::mytask_template
.Ve
.PP
And now the action:
.PP
.Vb 5
\& sub mytask {
\&     my ( $self ) = @_;
\&     my %params = ( foo => \*(Aqbar\*(Aq, baz => [ \*(Aqthis\*(Aq, \*(Aqthat\*(Aq ] );
\&     return $self\->generate_content( \e%params );
\& }
.Ve
.PP
What this gives us is the ability to swap out \fBvia configuration\fR a
separate display mechanism. For instance, I could specify the same
class in a different action but use a different content generator:
.PP
.Vb 3
\& [fooprime]
\& class = OpenInteract2::Action::Foo
\& content_generator = Wimpy
\& 
\& [fooprime template_source]
\& mytask = foo::mytask_wimpy_template
.Ve
.PP
So now the following URLs will reference the same code but have the
content generated by separate processes:
.PP
.Vb 2
\& /foo/mytask/
\& /fooprime/mytask/
.Ve
.PP
You can also specify a message key in place of the template name by
using the 'msg:' prefix before the message key:
.PP
.Vb 2
\& [foo template_source]
\& mytask = msg:foo.template
.Ve
.PP
This will find the proper template for the current user language,
looking in each message file for the key \f(CW\*(C`foo.template\*(C'\fR and using the
value there:
.PP
.Vb 2
\& mymsg_en.msg
\& foo.template = foo::mytask_template_english
\&
\& mymsg_es.msg
\& foo.template = foo::mytask_template_spanish
.Ve
.PP
\&\fBis_secure\fR (bool)
.PP
Whether to check security for this action. True is indicated by 'yes',
false by 'no' (or anything else).
.PP
The return value is not the same as the value set. It returns a true
value (1) if the action is secured (if set to 'yes'), a false one (0)
if not.
.PP
Example:
.PP
.Vb 8
\& if ( $action\->is_secure ) {
\&     my $level = CTX\->check_security({ class => ref $action });
\&     if ( $level < SEC_LEVEL_WRITE ) {
\&         $action\->param_add( error_msg => "Task forbidden due to security" );
\&         $action\->task( \*(Aqsearch_form\*(Aq );
\&         return $action\->execute;
\&     }
\& }
.Ve
.PP
\&\fBsecurity_required\fR ($)
.PP
If the action is using security, what level is required for the action
to successfully execute.
.PP
Example:
.PP
.Vb 8
\& if ( $action\->is_secure ) {
\&     my $level = CTX\->check_security({ class => ref $action });
\&     if ( $level < $action\->security_required ) {
\&         $action\->param_add( error_msg => "Task forbidden due to security" );
\&         $action\->task( \*(Aqsearch_form\*(Aq );
\&         return $action\->execute;
\&     }
\& }
.Ve
.PP
(Note: you will never need to do this since the
\&\f(CW\*(C`_find_security_level()\*(C'\fR method does this (and more) for you.)
.PP
\&\fBsecurity_level\fR ($)
.PP
This is the security level found or set for this action and task. If
you set this beforehand then the action dispatcher will not check it
for you:
.PP
Example:
.PP
.Vb 2
\& # Action dispatcher will check the security level of the current user
\& # for this action when \*(Aqexecute()\*(Aq is called.
\& 
\& my $action = OpenInteract2::Action\->new({
\&                    name           => \*(Aqbleeble\*(Aq,
\&                    task           => \*(Aqdisplay\*(Aq });
\& return $action\->execute;
\& 
\& # Action dispatcher will use the provided level and not perform a
\& # lookup for the security level on \*(Aqexecute()\*(Aq.
\& 
\& my $action = OpenInteract2::Action\->new({
\&                    name           => \*(Aqbleeble\*(Aq,
\&                    task           => \*(Aqdisplay\*(Aq,
\&                    security_level => SEC_LEVEL_WRITE });
\& return $action\->execute;
.Ve
.PP
\&\fBtask_valid\fR (\e@)
.PP
An arrayref of valid tasks for this action.
.PP
Example:
.PP
.Vb 2
\& my $ok_tasks = $action\->task_valid;
\& print "Tasks for this action: ", join( \*(Aq, \*(Aq, @{ $ok_tasks } ), "\en";
.Ve
.PP
\&\fBtask_invalid\fR (\e@)
.PP
An arrayref of invalid tasks for this action. Note that the action
dispatcher will \fBnever\fR execute a task with a leading underscore
(e.g., '_find_records'). This method will not return
leading-underscore tasks.
.PP
Example:
.PP
.Vb 2
\& my $bad_tasks = $action\->task_invalid;
\& print "Tasks not allowed for action: ", join( \*(Aq, \*(Aq, @{ $bad_tasks } ), "\en";
.Ve
.PP
\&\fBcache_expire\fR ($ or \e%)
.PP
Mapping of task name to expiration time for cached data in
seconds. You can also use shorthand to specify minutes, hours or days:
.PP
.Vb 3
\& 10m == 10 minutes
\& 3h  == 3 hours
\& 1d  == 1 day
.Ve
.PP
If you specify a single value it will be used for \fBall\fR tasks within
the action. Otherwise you can specify a per-task value using a
hashref.
.PP
.Vb 4
\& # default for all actions
\& [myaction]
\& class = MyPackage::Action::Foo
\& cache_expire = 2h
\& 
\& # different values for \*(Aqdisplay\*(Aq and \*(Aqlisting\*(Aq tasks
\& [myaction]
\& class = MyPackage::Action::Foo
\& 
\& [myaction cache_expire]
\& display = 2h
\& listing = 15m
.Ve
.PP
\&\fBcache_param\fR (\e%)
.PP
Mapping of task name to zero or more parameters (action/request) used
to identify the cached data. (See
OpenInteract2::Manual::Caching)
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\&\fBnew( [ \f(CB$name\fB | \f(CB$action\fB | \e%action_info ] [, \e%values ] )\fR
.PP
Create a new action. This has three flavors:
.IP "1." 4
If passed \f(CW$name\fR we ask the
OpenInteract2::Context to give us the action
information for \f(CW$name\fR. If the action is not found an exception is
thrown.
.Sp
Any action properties provided in \f(CW\*(C`\e%values\*(C'\fR will override the
default properties set in the action table. And any items in
\&\f(CW\*(C`\e%values\*(C'\fR that are not action properties will be set into the action
parameters, also overriding the values from the action table. (See
OpenInteract2::ParamContainer.)
.IP "2." 4
If given \f(CW$action\fR we call \f(CW\*(C`clone\*(C'\fR on it which creates an entirely
new action. Then we call \f(CW\*(C`init()\*(C'\fR on the new object and return
it. (\s-1TODO:\s0 is \fIinit()\fR redundant with a clone-type operation?)
.Sp
Any values provided in \f(CW\*(C`\e%properties\*(C'\fR will override the properties
from the \f(CW$action\fR. Likewise, any parameters from \f(CW\*(C`\e%properties\*(C'\fR
will override the parameters from the \f(CW$action\fR.
.IP "3." 4
If given \f(CW\*(C`\e%action_info\*(C'\fR we create a new action of the type found in
the 'class' key and assign the properties and paramters from the
hashref to the action. We also do a 'require' on the given class to
ensure it's available.
.Sp
Any values provided in \f(CW\*(C`\e%properties\*(C'\fR will override the properties
from \f(CW\*(C`\e%action_info\*(C'\fR. Likewise, any parameters from \f(CW\*(C`\e%properties\*(C'\fR
will override the parameters from the \f(CW\*(C`\e%action_info\*(C'\fR. It's kind of
beside the point since you can just pass them all in the first
argument, but whatever floats your boat.
.PP
Returns: A new action object; throws an exception if \f(CW$name\fR is
provided but not found in the \fBAction Table\fR.
.PP
Examples:
.PP
.Vb 1
\& # Create a new action of type \*(Aqnews\*(Aq, set the task and execute
\& 
\& my $action = OpenInteract2::Action\->new( \*(Aqnews\*(Aq );
\& $action\->task( \*(Aqdisplay\*(Aq );
\& $action\->execute;
\& 
\& # $new_action and $action are equivalent...
\& 
\& my $new_action =
\&     OpenInteract2::Action\->new( $action );
\&
\& # ...and this does not affect $action at all
\& 
\& $new_action\->task( \*(Aqlist\*(Aq );
\& 
\& my $action = OpenInteract2::Action\->new( \*(Aqnews\*(Aq );
\& $action\->task( \*(Aqdisplay\*(Aq );
\& $action\->param( soda => \*(Aqcoke\*(Aq );
\& 
\& # $new_action and $action are equivalent except for the \*(Aqsoda\*(Aq
\& # parameter and the \*(Aqtask\*(Aq property
\& 
\& my $new_action =
\&     OpenInteract2::Action\->new( $action, { soda => \*(Aqmr. pibb\*(Aq,
\&                                            task => \*(Aqlist\*(Aq } );
\& 
\& # Create a new type of action on the fly
\& # TODO: will this work?
\& 
\& my $action = OpenInteract2::Action\->new({
\&         name         => \*(Aqfoo\*(Aq,
\&         class        => \*(AqOpenInteract2::Action::FooAction\*(Aq,
\&         task_default => \*(Aqdrink\*(Aq,
\&         soda         => \*(AqJolt\*(Aq,
\& });
.Ve
.SS "Object Methods"
.IX Subsection "Object Methods"
\&\fB\f(BIinit()\fB\fR
.PP
This method allows action subclasses to perform any additional
initialization required. Note that before this method is called from
\&\f(CW\*(C`new()\*(C'\fR all of the properties and parameters from \f(CW\*(C`new()\*(C'\fR have been
set into the object whether you have created it using a name or by
cloning another action.
.PP
If you define this you \fBmust\fR call \f(CW\*(C`SUPER::init()\*(C'\fR so that all
parent classes have a chance to perform initialization as well.
.PP
Returns: The action object, or undef if initialization failed.
.PP
Example:
.PP
.Vb 1
\& package OpenInteract2::Action::MyAction;
\& 
\& use base qw( OpenInteract2::Action );
\& 
\& my %DEFAULTS = ( foo => \*(Aqbar\*(Aq, baz => \*(Aqquux\*(Aq );
\& sub init {
\&     my ( $self ) = @_;
\&     while ( my ( $key, $value ) = each %DEFAULTS ) {
\&         unless ( $self\->param( $key ) ) {
\&             $self\->param( $key, $value );
\&         }
\&     }
\&     return $self\->SUPER::init();
\& }
.Ve
.PP
\&\fB\f(BIclone()\fB\fR
.PP
For now this is pretty simplistic: create an empty action object using
the same class as then given object (call it \f(CW$action\fR) and fill it
with the properties and parameters from \f(CW$action\fR.
.PP
Returns: new action object of the same class as \f(CW$action\fR
.PP
\&\fBcreate_url( \e%params )\fR
.PP
Generate a self-referencing \s-1URL\s0 to this action, using \f(CW\*(C`\e%params\*(C'\fR as
an appended query string. Under the covers we use
OpenInteract2::URL to do the real work.
.PP
Note that you can also override the task set in the current action
using the '\s-1TASK\s0' parameter. So you could be on the form display for a
particular object and generate a \s-1URL\s0 for the removal task by passing
\&'remove' in the '\s-1TASK\s0' parameter.
.PP
See \*(L"\s-1MAPPING\s0 \s-1URL\s0 \s-1TO\s0 \s-1ACTION\s0\*(R" for a discussion of how an action is
mapped to multiple URLs and which \s-1URL\s0 will be chosen as the base for
the \s-1URL\s0 generated by this method.
.PP
Returns: \s-1URL\s0 for this action
.PP
Examples:
.PP
.Vb 10
\& my $action = OpenInteract2::Action\->new({
\&     name => \*(Aqgames\*(Aq,
\&     task => \*(Aqexplore\*(Aq,
\& });
\& my $url = $action\->create_url;
\& # $url: "/games/explore/"
\& my $url = $action\->create_url({ edit => \*(Aqyes\*(Aq });
\& # $url: "/games/explore/?edit=yes"
\& my $url = $action\->create_url({ TASK => \*(Aqedit\*(Aq, game_id => 42 });
\& # $url: "/games/edit/?game_id=42"
\& 
\& <a href="[% action.create_url( edit = \*(Aqyes\*(Aq ) %]">Click me!</a>
\& # <a href="/games/explore/?edit=yes">Click me!</a>
\& <a href="[% action.create_url( task = \*(AqEDIT\*(Aq, game_id = 42 ) %]">Click me!</a>
\& # <a href="/games/edit/?game_id=42">Click me!</a>
\& 
\& CTX\->assign_deploy_url( \*(Aq/Archives\*(Aq );
\& my $url = $action\->create_url;
\& # $url: "/Archives/games/explore/"
\& my $url = $action\->create_url({ edit => \*(Aqyes\*(Aq });
\& # $url: "/Archives/games/explore/?edit=yes"
\& my $url = $action\->create_url({ TASK => \*(Aqedit\*(Aq, game_id => 42 });
\& # $url: "/Archives/games/edit/?game_id=42"
\& 
\& <a href="[% action.create_url( edit = \*(Aqyes\*(Aq ) %]">Click me!</a>
\& # <a href="/Archives/games/explore/?edit=yes">Click me!</a>
\& <a href="[% action.create_url( task = \*(AqEDIT\*(Aq, game_id = 42 ) %]">Click me!</a>
\& # <a href="/Archives/games/edit/?game_id=42">Click me!</a>
.Ve
.PP
\&\fBget_dispatch_urls\fR
.PP
Retrieve an arrayref of the URLs this action is dispatched under. This
may be an empty arrayref if the action is not URL-accessible.
.PP
This is normally only called at
OpenInteract2::Context startup when it reads
in the actions from all the packages, but it might be informative
elsewhere as well. (For instance, we use it in the management task
\&'list_actions' to show all the URLs each action responds to.) See
\&\*(L"\s-1MAPPING\s0 \s-1URL\s0 \s-1TO\s0 \s-1ACTION\s0\*(R" for how the method works.
.PP
Returns: arrayref of URLs this action is dispatched under.
.PP
Example:
.PP
.Vb 5
\& my $urls = $action\->get_dispatch_urls;
\& print "This action is available under the following URLs: \en";
\& foreach my $url ( @{ $urls } ) {
\&     print " *  $url\en";
\& }
.Ve
.SS "Object Execution Methods"
.IX Subsection "Object Execution Methods"
\&\fBexecute( \e%vars )\fR
.PP
Generate content for this action and task. If the task has an error it
can generate error content and \f(CW\*(C`die\*(C'\fR with it; it can also just \f(CW\*(C`die\*(C'\fR
with an error message, but that is not very helpful to your users.
.PP
The \f(CW\*(C`\e%vars\*(C'\fR argument will set properties and parameters (via
\&\f(CW\*(C`property_assign()\*(C'\fR and \f(CW\*(C`param_assign()\*(C'\fR) before generating the
content.
.PP
Most actions do not implement this method, instead implementing a task
and using the base class implementation of \f(CW\*(C`execute()\*(C'\fR to:
.IP "\(bu" 4
lookup the task
.IP "\(bu" 4
perform the necessary security checks
.IP "\(bu" 4
match up additional \s-1URL\s0 parameters from the request to action parameters
.IP "\(bu" 4
check the cache for matching content (More about caching in
OpenInteract2::Manual::Caching.)
.IP "\(bu" 4
after the content has been generated, store the content in the cache as necessary
.PP
Returns: content generated by the action
.PP
\&\fBforward( \f(CB$new_action\fB )\fR
.PP
\&\s-1TODO:\s0 may get rid of this
.PP
Forwards execution to \f(CW$new_action\fR.
.PP
Returns: content generated by calling \f(CW\*(C`execute()\*(C'\fR on \f(CW$new_action\fR.
.PP
Examples:
.PP
.Vb 6
\& sub edit {
\&     my ( $self ) = @_;
\&     # ... do edit ...
\&     my $list_action = CTX\->lookup_action( \*(Aqobject_list\*(Aq );
\&     return $self\->forward( $list_action );
\& }
.Ve
.PP
\&\fB\f(BIclear_cache()\fB\fR
.PP
Most caching is handled for you using configuration declarations and
callbacks in \f(CW\*(C`execute()\*(C'\fR. The one part that cannot be easily
specified is when objects change. If your action is using caching then
you will probably need to call \f(CW\*(C`clear_cache()\*(C'\fR whenever you modify
objects whose content may be cached. \*(L"Probably\*(R" because your app may
not care that some stale data is served up for a little while.
.PP
For instance, if you are caching the latest news items and add a new
one you do not want your 'latest' listing to miss the entry you just
added. So you clear out the old cache entries and let them get rebuilt
on demand.
.PP
Since we do not want to create a crazy dependency graph of data that
is eventually going to expire anyway, we just remove all cache entries
generated by this class.
.PP
Returns: number of cache entries removed
.SS "Object Content Methods"
.IX Subsection "Object Content Methods"
\&\fBgenerate_content( \e%content_params, [ \e%template_source ], [ \e%template_params ] )\fR
.PP
This is used to generate content for an action.
.PP
The information in \f(CW\*(C`\e%template_source\*(C'\fR is only optional if you have
specified the source in your action configuration. See the docs for
property \fBtemplate_source\fR for more information.
.PP
Also, note that any view messages you have added via
\&\f(CW\*(C`view_messages()\*(C'\fR or \f(CW\*(C`add_view_message()\*(C'\fR will be passed to the
template in the key \f(CW\*(C`action_messages\*(C'\fR.
.PP
\&\s-1TODO:\s0 fill in more: how to id content
.SS "Object Property and Parameter Methods"
.IX Subsection "Object Property and Parameter Methods"
See OpenInteract2::ParamContainer for discussion of the \f(CW\*(C`param()\*(C'\fR,
\&\f(CW\*(C`param_add()\*(C'\fR, \f(CW\*(C`param_clear()\*(C'\fR and \f(CW\*(C`param_assign()\*(C'\fR methods.
.PP
\&\fBproperty_assign( \e%properties )\fR
.PP
Assigns values from properties specified in \f(CW\*(C`\e%properties\*(C'\fR. Only the
valid properties for actions will be set, everything else will be
skipped.
.PP
Currently we only set properties for which there is a defined value in
\&\f(CW\*(C`\e%properties\*(C'\fR.
.PP
Returns: action object (\f(CW$self\fR)
.PP
See \s-1PROPERTIES\s0 for the list of properties in each action.
.PP
\&\fBproperty( [ \f(CB$name\fB, \f(CB$value\fB ] )\fR
.PP
Get/set action properties. (In addition to direct method call, see
below.) This can be called in three ways:
.PP
.Vb 3
\& my $props   = $action\->property;            # $props is hashref
\& my $value   = $action\->property( $name );   # $value is any type of scalar
\& $new_value  = $action\->property( $name, $new_value );
.Ve
.PP
Returns: if called without arguments, returns a copy of the hashref of
properties attached to the action (changes made to the hashref will
not affect the action); if called with one or two arguments, returns
the new value of the property \f(CW$name\fR.
.PP
Note that this performs the same action as the direct method call with
the property name:
.PP
.Vb 3
\& # Same
\& $action\->property( \*(Aqtask_invalid\*(Aq );
\& $action\->task_invalid();
\& 
\& # Same
\& $action\->property( task_invalid => [ \*(Aqfoo\*(Aq ] );
\& $action\->task_invalid( [ \*(Aqfoo\*(Aq ] );
.Ve
.PP
See \s-1PROPERTIES\s0 for the list of properties in each action.
.PP
\&\fBproperty_clear( \f(CB$key\fB )\fR
.PP
Sets the property defined by \f(CW$key\fR to \f(CW\*(C`undef\*(C'\fR. This is the only way
to unset a property.
.PP
Returns: value previously set for the property \f(CW$key\fR.
.PP
See \s-1PROPERTIES\s0 for the list of properties in each action.
.PP
\&\fB\f(BIproperty_info()\fB\fR
.PP
Get a hash of all property names and descriptions \*(-- used in a
management task so you can easily lookup properties without jumping
into the (fairly long) docs.
.PP
\&\fBparam_from_request( \f(CB@param_names\fB )\fR
.PP
Sets the action parameter value to the request parameter value for
each name in \f(CW@param_names\fR.
.PP
This will overwrite existing action parameters if they are not already
defined.
.PP
Returns: nothing
.PP
\&\fBadd_error( \f(CB@msg\fB )\fR
.PP
Adds message (\f(CW\*(C`join\*(C'\fRed \f(CW\*(C`msg\*(C'\fR) to parameter 'error_msg').
.PP
Returns: added message
.PP
\&\fBadd_status( \f(CB@msg\fB )\fR
.PP
Adds message (\f(CW\*(C`join\*(C'\fRed \f(CW\*(C`msg\*(C'\fR) to parameter 'status_msg').
.PP
Returns: added message
.PP
\&\fBadd_error_key( \f(CB$key\fB, [ \f(CB@msg_params\fB ] )\fR
.PP
Adds error message (under param name 'error_msg') using the resource
key \f(CW$key\fR which may also optionally need \f(CW@msg_params\fR.
.PP
Returns: added message
.PP
\&\fBadd_status_key( \f(CB$key\fB, [ \f(CB@msg_params\fB ] )\fR
.PP
Adds status message (under param name 'status_msg') using the resource
key \f(CW$key\fR which may also optionally need \f(CW@msg_params\fR.
.PP
Returns: added message
.PP
\&\fB\f(BIclear_error()\fB\fR
.PP
Removes all error messages.
.PP
\&\fB\f(BIclear_status()\fB\fR
.PP
Removes all status messages.
.PP
\&\fBmessage_from_key_or_param( \f(CB$param_name\fB, \f(CB$message_key\fB, \f(CB@key_arguments\fB )\fR
.PP
Shortcut for returning a message from either the localized message
store or from the given parameter. For instance, you might have an
action configured:
.PP
.Vb 3
\& [myaction]
\& title = This is a generic title
\& title_key = mypkg.myaction.title
.Ve
.PP
If you call:
.PP
.Vb 1
\& my $msg = $myaction\->message_from_key_or_param( \*(Aqtitle\*(Aq, \*(Aqtitle_key\*(Aq );
.Ve
.PP
The \f(CW$msg\fR variable should have whatever is in the localization table
for 'mypkg.myaction.title'. If 'title_key' wasn't defined the method
would return 'This is a generic title'.
.PP
Returns: message from localization tables or from the action parameter
.PP
\&\fBview_messages( [ \e%messages ] )\fR
.PP
Returns the message names and associated messages in this
action. These may have been set directly or they may have been
deposited in the request (see \f(CW\*(C`action_messages()\*(C'\fR in
OpenInteract2::Request) and picked up at
action instantiation.
.PP
Note that these get put in the template content variable hashref under
the key \f(CW\*(C`action_messages\*(C'\fR as long as the content is generated using
\&\f(CW\*(C`generate_content()\*(C'\fR.
.PP
Returns: hashref of view errors associated with this action; may be an
empty hashref.
.PP
\&\fBadd_view_message( \f(CB$msg_name\fB, \f(CB$msg\fB )\fR
.PP
Assign the view messgate \f(CW$msg_name\fR as \f(CW$msg\fR in this action.
.SS "Internal Object Execution Methods"
.IX Subsection "Internal Object Execution Methods"
You should only need to know about these methods if you are creating
your own action.
.PP
\&\fB_msg( \f(CB$key\fB, \f(CB@args\fB )\fR
.PP
Shortcut to creating a localized message. Under the hood this calls:
.PP
.Vb 1
\& CTX\->request\->language_handle\->maketext( $key, @args );
.Ve
.PP
Example:
.PP
.Vb 5
\& if ( $@ ) {
\&     $action\->param_add(
\&         error_msg => $action\->_msg( \*(Aqmy.error.message\*(Aq, "$@" )
\&     );
\& }
.Ve
.PP
\&\fB\f(BI_find_task()\fB\fR
.PP
Tries to find a task for the action. In order, the method looks:
.IP "\(bu" 4
In the 'method' property of the action. This means the action is
hardwired to a particular method and cannot be changed, even if you
set 'task' manually.
.Sp
\&\s-1TODO:\s0 This might change... why use 'method' when we could keep with
the task terminology and use something like 'task_concrete' or
\&'task_only'?
.IP "\(bu" 4
In the 'task' property of the action: it might already be defined!
.IP "\(bu" 4
In the 'task_default' property of the action.
.PP
If a task is not found we throw an exception.
.PP
Returns: name of task.
.PP
\&\fB\f(BI_check_task_validity()\fB\fR
.PP
Ensure that task assigned is valid. If it is not we throw an
OpenInteract2::Exception.
.PP
A valid task:
.IP "\(bu" 4
does not begin with an underscore.
.IP "\(bu" 4
is not listed in the \f(CW\*(C`task_invalid\*(C'\fR property.
.IP "\(bu" 4
is listed in the \f(CW\*(C`task_valid\*(C'\fR property if that property is defined.
.PP
Returns: nothing, throwing an exception if the check fails.
.PP
\&\fB\f(BI_find_task_method()\fB\fR
.PP
Finds a valid method to call for the action task. If the method
\&\f(CW\*(C`handler()\*(C'\fR is defined in the action class or any of its parents,
that is called. Otherwise we check to see if the method \f(CW\*(C`$task()\*(C'\fR \*(--
which should already have been checked for validity \*(-- is defined in
the action class or any of its parents. If neither is found we throw
an exception.
.PP
You are currently not allowed to have a task of the same name as one
of the action properties. If you try to execute a task by this name
you will get a message in the error log to this effect.
.PP
Note that we cache the returned code reference, so if you do something
funky with the symbol table or the \f(CW@ISA\fR for your class after a
method has been called, everything will be mucked up.
.PP
Returns: code reference to method for task.
.PP
\&\fB\f(BI_check_security()\fB\fR
.PP
Checks security for this action. On failure throws a security
exception, on success returns the security level found (also set in
the action property \f(CW\*(C`security_level\*(C'\fR). Here are the steps we go
through:
.IP "\(bu" 4
First we get the security level for this action. If already set (in
the \f(CW\*(C`security_level\*(C'\fR property) we use that. Otherwise we call
\&\f(CW\*(C`_find_security_level\*(C'\fR to determine the level. This is set in the
action property \f(CW\*(C`security_level\*(C'\fR.
.IP "\(bu" 4
If the action is not secured we short-circuit operations and return
the security level.
.IP "\(bu" 4
Third, we ensure that the action property \f(CW\*(C`security\*(C'\fR contains a
hashref. If not we throw an exception.
.IP "\(bu" 4
Next, we determine the security level required for this particular
task. If neither the task nor '\s-1DEFAULT\s0' is defined in the hashref of
security requirements, we assume that \f(CW\*(C`SEC_LEVEL_WRITE\*(C'\fR security is
required.
.Sp
The level found is set in the action property \f(CW\*(C`security_required\*(C'\fR.
.IP "\(bu" 4
Finally, we compare the \f(CW\*(C`security_level\*(C'\fR with the
\&\f(CW\*(C`security_required\*(C'\fR. If the required level is greater we throw a
security exception.
.PP
Returns: security level for action if security check okay, exception
if not.
.PP
\&\fB\f(BI_find_security_level()\fB\fR
.PP
Returns the security level for this combination of action, user and
groups. First it looks at the 'is_secure' action property \*(-- if true we
continue, otherwise we return \f(CW\*(C`SEC_LEVEL_WRITE\*(C'\fR so the system will
allow any user to perform the task.
.PP
If the action is secured we find the actual security level for this
action and user and return it.
.PP
Returns: security level for action given current user and groups.
.SH "TO DO"
.IX Header "TO DO"
\&\fB\s-1URL\s0 handling\fR
.PP
How we respond to URLs and the URLs we generate for ourselves is a
little confusing. We may want to ensure that when a use requests an
alternate \s-1URL\s0 \*(-- for instance '/Nouvelles/' for '/News/' \*(-- that the
\&\s-1URL\s0 generated from '\fIcreate_url()\fR' also uses '/Nouvelles/'. Currently
it does not, since we're using \s-1OI2::URL\s0 to generate the \s-1URL\s0 for us and
on the method call it's divorced from the action state.
.PP
We could get around this with an additional property 'url_requested'
(or something) which would only be set in the constructor if the
\&'\s-1REQUEST_URL\s0' is passed in. Then the 'create_url' would use it and
call the 'create' method rather than 'create_from_action' method in
\&\s-1OI2::URL\s0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
OpenInteract2::Context
.PP
OpenInteract2::URL
.PP
Class::Observable
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
