.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Conversion::IniConfig 3"
.TH OpenInteract2::Conversion::IniConfig 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Conversion::IniConfig \- Parent class for converting perl configurations to INI format
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use base qw( OpenInteract2::Conversion::IniConfig );
\& 
\& sub get_field_order {
\&     return [ qw/ one two three four / ];
\& }
\& 
\& sub init {
\&     my ( $self ) = @_;
\&     $self\->transforms({ three => \e&_modify_three,
\&                         four  => \e&_modify_four });
\&     return $self;
\& }
\& 
\& # Instead of numbers use categories:
\& # < 0   \- sub
\& # < 5   \- min
\& # < 20  \- norm
\& # >= 20 \- max
\& 
\& sub _modify_three {
\&     my ( $name, $value ) = @_;
\&     return unless ( defined $value );
\&     if ( $value < 0 ) {
\&         return ( $name, \*(Aqsub\*(Aq );
\&     }
\&     elsif ( $value < 5 ) {
\&         return ( $name, \*(Aqmin\*(Aq );
\&     }
\&     elsif ( $value < 20 ) {
\&         return ( $name, \*(Aqnorm\*(Aq );
\&     }
\&     else {
\&         return ( $name, \*(Aqmax\*(Aq );
\&     }
\& }
\& 
\& # Rename field to \*(Aqfore\*(Aq
\& 
\& sub _modify_four {
\&     my ( $name, $value ) = @_;
\&     return ( \*(Aqfore\*(Aq, $value );
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides methods to convert a serialized perl data
structure into an \s-1INI\s0 file. There are restrictions on the structures
\&\*(-- you can have only one contained hash reference, and no subroutine
references. But the resulting configuration is much easier for humans
to read and edit.
.SH "METHODS"
.IX Header "METHODS"
\&\fBnew( \f(CB$old_content\fB )\fR
.PP
Creates a new object, initializing it with the text \f(CW$old_content\fR
representing a serialized perl data structure. This is tested with
structures serialized by Data::Dumper, but others
probably work ok.
.PP
\&\fB\f(BIinit()\fB\fR
.PP
Allows subclasses to perform initialization, normally to register
transformations. Called just after object initialized in \f(CW\*(C`new()\*(C'\fR with
the optional content passed in.
.PP
\&\fB\f(BIconvert()\fB\fR
.PP
Perform the actual data conversion. You must have set the perl data
structure content either in the constructor or by calling
\&\f(CW\*(C`old_content()\*(C'\fR (with the text) or \f(CW\*(C`old_config()\*(C'\fR (with the actual
data structure), otherwise the method will die. Similarly, if the
content does not evaluate to a proper perl data structure, or if it
evaluates to something other than a hashref, the method will die.
.PP
Otherwise we step through the hashref in the order defined by a
subclass (using \f(CW\*(C`get_field_order()\*(C'\fR) and convert the value for each
key into one or more key/value string pairs, possibly transforming the
key and/or value before the conversion.
.PP
\&\fBserialize( [ \f(CB$raw_content\fB ] )\fR
.PP
Serializes \f(CW$raw_content\fR (or the return of \f(CW\*(C`raw_content()\*(C'\fR if not
provided) into an INI-style configuration. This is stored in
\&\f(CW\*(C`new_content()\*(C'\fR and also returned from the method.
.PP
\&\fBold_config( [ \e%config ] )\fR
.PP
Gets/sets the configuration used to generate the \s-1INI\s0. You can set the
configuration directly rather than setting the serialized perl
datastructure text in \f(CW\*(C`old_content()\*(C'\fR.
.PP
\&\fBold_content( [ \f(CB$text\fB ] )\fR
.PP
Sets/returns the text used for the serialized perl data
structure. This must be set (either here or in the constructor) before
calling \f(CW\*(C`convert()\*(C'\fR.
.PP
\&\fB\f(BInew_content()\fB\fR
.PP
Returns the generated content. This is set implicitly by
\&\f(CW\*(C`serialize()\*(C'\fR and cannot be set externally.
.PP
\&\fB\f(BIraw_content()\fB\fR
.PP
Returns the raw content. This consists of an array of arrayrefs. Each
arrayref is a section in the \s-1INI\s0 file \*(-- the first member is the label
and every remaining member is a key/value pair under that label.
.PP
This is set implicitly by \f(CW\*(C`convert()\*(C'\fR and cannot be set externally.
.PP
\&\fBtransforms( \e%transforms )\fR
.PP
Get/set the transformation routines for the configuration. See
\&\*(L"Transforming Data\*(R" below for what the routines can do and what they
should return.
.SS "Transforming Data"
.IX Subsection "Transforming Data"
A subclass or caller has the ability to register transformation
handlers with the converter. Each transformation handler is a code
reference that is passed two arguments: a \f(CW$name\fR and \f(CW$value\fR. The
\&\f(CW$name\fR is the name of the configuration key, the \f(CW$value\fR is its
value. (duh) It's best to explain with an example:
.PP
.Vb 5
\& sub _modify_true_to_yes {
\&     my ( $name, $value ) = @_;
\&     return ( $name, \*(Aqno\*(Aq )  unless ( $value );
\&     return ( $name, \*(Aqyes\*(Aq );
\& }
.Ve
.PP
This will change something like:
.PP
.Vb 2
\& increment_field => 1,
\& field_discover  => 0,
.Ve
.PP
into:
.PP
.Vb 2
\& increment_field = yes
\& field_discover  = no
.Ve
.PP
You can change both the field name and the field value, and you must
return both even if you don't modify them.
.PP
Normally a subclass with register these transformations in its
\&\f(CW\*(C`init()\*(C'\fR method:
.PP
.Vb 6
\& sub init {
\&     my ( $self ) = @_;
\&     $self\->transforms({ increment_field => \e&_modify_true_to_yes,
\&                         field_discover  => \e&_modify_true_to_yes });
\&    return $self;
\& }
.Ve
.PP
A common use of the transformations is to flatten a second-level
hashref into an arrayref of parseable text. For instance, in the \s-1SPOPS\s0
configuration the 'creation_security' key has a hashref as a value,
and the 'g' key of that hashref could have another hashref as a
value. In the new configuration it cannot, so we need to change it to
fit our scheme. One idea is to change:
.PP
.Vb 5
\& creation_security => {
\&   u => \*(AqREAD\*(Aq,
\&   g => { 3 => \*(AqWRITE\*(Aq },
\&   w => undef,
\& }
.Ve
.PP
into something like this:
.PP
.Vb 5
\& creation_security => {
\&   u => \*(AqREAD\*(Aq,
\&   g => [ \*(Aq3:WRITE\*(Aq ],
\&   w => undef,
\& }
.Ve
.PP
which the normal process can handle nicely.
.SH "BUGS"
.IX Header "BUGS"
None known.
.SH "TO DO"
.IX Header "TO DO"
Nothing known.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
