.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::FullTextIndexer 3"
.TH OpenInteract2::FullTextIndexer 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::FullTextIndexer \- Base class for OI2 indexers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& my $indexer = CTX\->fulltext_indexer;
\& 
\& # Or lookup a specific indexer:
\& my $indexer = CTX\->fulltext_indexer( \*(AqPlucene\*(Aq );
\& 
\& # Add something to the index
\& $indexer\->add_to_index( \*(Aqpage\*(Aq, \*(Aq/foo/listing.html\*(Aq, \e$foo_content );
\& 
\& # Remove all index entries for something
\& $indexer\->remove_from_index( \*(Aqpage\*(Aq, \*(Aq/foo/listing.html\*(Aq );
\& 
\& # Refresh the index for a particular item
\& $indexer\->refresh_index( \*(Aqpage\*(Aq, \*(Aq/foo/listing.html\*(Aq, \e$new_foo_content );
\& 
\& # Search the index with default \*(Aqreturn_type\*(Aq = \*(Aqobject\*(Aq
\& my $results = $indexer\->search_index({
\&     search_type => \*(Aqall\*(Aq,
\&     terms       => [ \*(Aqulysses\*(Aq, \*(Aqgrant\*(Aq ],
\& });
\& foreach my $result ( @{ $results } ) {
\&     my $object = $result\->[0];
\&     my $score  = $result\->[1];
\&     print "Object ", ref( $object ), " with ID ", $object\->id, " ",
\&           "was found with a score of $score\en";
\& }
\& 
\& # Search the index with different return types
\& 
\& # return type of \*(Aqiterator\*(Aq returns OpenInteract2::FullTextIterator
\& 
\& my $results = $indexer\->search_index({
\&     search_type => \*(Aqall\*(Aq,
\&     terms       => [ \*(Aqulysses\*(Aq, \*(Aqgrant\*(Aq ],
\&     return_type => \*(Aqiterator\*(Aq,
\& });
\& while ( my $object = $results\->get_next ) {
\&     print "Object ", ref( $object ), " with ID ", $object\->id, " ",
\&           "was found\en";
\& }
\& 
\& # get additional information from iterator...
\& while ( my ( $object, $item_num, $score ) = $results\->get_next ) {
\&     print "Object $item_num is a ", ref( $object ), " with ID ",
\&           $object\->id, " and a score of $score\en";
\& }
\& 
\& # return type of \*(Aqraw\*(Aq returns arrayref of arrayrefs
\& 
\& my $results = $indexer\->search_index({
\&     search_type => \*(Aqall\*(Aq,
\&     terms       => [ \*(Aqulysses\*(Aq, \*(Aqgrant\*(Aq ],
\&     return_type => \*(Aqraw\*(Aq,
\& });
\& foreach my $result ( @{ $results } ) {
\&     my ( $class, $id, $full_score, $score_info ) = @{ $result };
\&     print "Object $class with ID $id was found with total score ",
\&           "$full_score and individual term scores:\en";
\&     foreach my $term ( keys %{ $score_info } ) {
\&         print "  * $term: $score_info\->{$term}\en";
\&     }
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for full-text indexers in OpenInteract2. All
objects returned by the OpenInteract2::Context method
\&\f(CW\*(C`fulltext_indexer()\*(C'\fR will meet this interface.
.SH "METHODS"
.IX Header "METHODS"
.SS "Public Interface"
.IX Subsection "Public Interface"
\&\fBnew( \e%params )\fR
.PP
Instantiates a new indexer with parameters \f(CW\*(C`\e%params\*(C'\fR.
.PP
You should not call this directly but instead get an indexer from the
OpenInteract2::Context object:
.PP
.Vb 2
\& # get the default indexer
\& my $indexer = CTX\->fulltext_indexer;
\& 
\& # get a specific indexer
\& my $indexer = CTX\->fulltext_indexer( \*(Aqsoundex\*(Aq );
.Ve
.PP
\&\fBadd_to_index( \f(CB$content_class\fB, \f(CB$content_id\fB, \e$content_text )\fR
.PP
Indexes the text in the scalar reference \f(CW\*(C`\e$content_text\*(C'\fR,
categorizing it with \f(CW$content_class\fR and \f(CW$content_id\fR. The text in
\&\f(CW\*(C`\e$content_text\*(C'\fR is not modified by this operation.
.PP
While \f(CW$content_class\fR is typically an \s-1SPOPS\s0 subclass, it does not
have to be. The class merely has to be able to retrieve, identify and
describe an object. To do this it must implement:
.IP "\(bu" 4
Class method: \fBfetch( \f(CB$id\fB )\fR
.Sp
Returns an object with identifier \f(CW$id\fR.
.IP "\(bu" 4
Object method: \fB\f(BIid()\fB\fR
.Sp
Returns the identifier for an object.
.IP "\(bu" 4
Object method: \fB\f(BIobject_description()\fB\fR
.Sp
Should return a hashref with the keys as described in \fB\s-1SPOPS\s0\fR under
\&\fB\f(BIobject_description()\fB\fR.
.PP
\&\fBrefresh_index( \f(CB$content_class\fB, \f(CB$content_id\fB, \e$content_ref )\fR
.PP
Removes existing records from the index marked by \f(CW$content_class\fR
and \f(CW$content_id\fR then indexes \f(CW\*(C`\e$content_ref\*(C'\fR.
.PP
\&\fBremove_from_index( \f(CB$content_class\fB, \f(CB$content_id\fB )\fR
.PP
Deletes all records from the index marked by \f(CW$content_class\fR and
\&\f(CW$content_id\fR.
.PP
\&\fBsearch_index( \e%params )\fR
.PP
Searches the index given the data in \f(CW\*(C`\e%params\*(C'\fR:
.IP "\(bu" 4
\&\fBterms\fR (\e@)
.Sp
Arrayref of terms to search for.
.IP "\(bu" 4
\&\fBsearch_type\fR ($): 'all' (default) or 'any'
.Sp
Determines if matching records must have all or any of the given
terms.
.IP "\(bu" 4
\&\fBreturn_type\fR ($): 'object' (default), 'iterator' or 'raw'
.Sp
Determines what type of data to return.
.Sp
Using 'object' means you get back an arrayref of two-item arrayrefs \*(--
the first is the object, the second the match score.
.Sp
Using 'iterator' means you get back a
OpenInteract2::FullTextIterator object.
.Sp
Using 'raw' means you get back an arrayref of four-item arrayrefs \-
the first is the class, the second the \s-1ID\s0, the third the full-score
for this match and the fourth a hashref of match scores the keys as
the terms searched and the values the match score for that
term. (Generally this is just a count of the number of occurrences,
but implementations are free to do whatever they want.)
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Optional Methods"
.IX Subsection "Optional Methods"
In addition to overriding the interface method \f(CW\*(C`search_index()\*(C'\fR
subclasses can implement:
.PP
\&\fBinit( \e%params )\fR
.PP
Gives you a chance to set values from \f(CW\*(C`\e%params\*(C'\fR in the object.
.PP
No return value necessary.
.PP
\&\fB_screen_results( \f(CB$search_type\fB, \f(CB$results\fB, \f(CB@search_terms\fB )\fR
.PP
Remove any records from \f(CW$results\fR \*(-- which is the return value from
\&\f(CW\*(C`_run_search()\*(C'\fR, below \*(-- that do not correspond to
\&\f(CW$search_type\fR. The default implementation only acts when given a
\&\f(CW$search_type\fR of 'all', removing records that do not have matches
for all the \f(CW@search_terms\fR.
.PP
Return value should be an arrayref of the new results.
.SS "Mandatory Methods"
.IX Subsection "Mandatory Methods"
Subclasses must implement:
.PP
\&\fBadd_to_index( \f(CB$content_class\fB, \f(CB$content_id\fB, \e$content_ref )\fR
.PP
\&\fBremove_from_index( \f(CB$content_class\fB, \f(CB$content_id\fB )\fR
.PP
\&\fB_run_search( \f(CB$search_type\fB, \f(CB@search_terms\fB)\fR
.PP
The \f(CW$search_type\fR is either 'any' or 'all'. This should \fBonly\fR
return an arrayref of records like this:
.PP
.Vb 1
\& [ $class, $id, full\-score, { search\-term => term\-score, ... } ]
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
OpenInteract2::FullTextIterator
.PP
The 'full_text' package shipped with \s-1OI2\s0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
