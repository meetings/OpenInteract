.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Manual::Caching 3"
.TH OpenInteract2::Manual::Caching 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Manual::Caching \- Storing generated data for later reuse
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Caching can not only provide a dramatic speedup to certain types of
content, it can mean the difference between scaling when you hit the
big time and falling on your face. Even much highly dynamic content
can be cached.
.PP
There are two different levels of caching in OpenInteract:
.IP "\(bu" 4
\&\fBContent\fR: Once a component has been generated with a particular set
of parameters, we don't want to regenerate it again.
.IP "\(bu" 4
\&\fBTemplates\fR: Once a template has been parsed we don't want to repeat
those actions again. This is fairly minor and should be handled by
whatever templating system you're using.
.SH "CONTENT CACHING"
.IX Header "CONTENT CACHING"
Content caching is still fairly young in OpenInteract, and it's not
appropriate (or useful) for all purposes. It's best when used on
content that:
.IP "\(bu" 4
doesn't have any side-effects, and
.IP "\(bu" 4
contain a lot of data and/or
.IP "\(bu" 4
require a good deal of processing.
.SS "Avoiding Side-Effects"
.IX Subsection "Avoiding Side-Effects"
First, you have to ensure that the action producing the content you're
caching has no side-effects. Otherwise the first invocation will work
properly the every subsequent one will fail because it does not
produce the side-effects you're looking for.
.PP
Here are some examples of what we mean by side-effects:
.IP "\(bu" 4
The action actually modifies an object. (Hopefully this is obvious!)
Because the action never gets run the object will never be modified.
.IP "\(bu" 4
The action increments a counter in a database every time an object is
viewed. Again, the action will never be run so the counter won't be
incremented.
.IP "\(bu" 4
The template used by the action adds a box to the page. Since the
action isn't run the template isn't invoked and the command to add the
box won't be executed.
.PP
These are poor candidates for caching. You might still be able to
cache the content with creative action observer uses, but you should
tread cautiously and understand what you're doing.
.SS "Admins: Another Time Not to Cache"
.IX Subsection "Admins: Another Time Not to Cache"
If you're an admin user you frequently see functionality that normal
users do not see: \fBEdit\fR or \fBRemove\fR links next to an object, etc.
You do not want to cache this content, since users shouldn't see this
information. (Normal users modifying the object shouldn't be an issue,
since security should take care of it.)
.PP
As a result, any user defined as an administrator will not view or save
cached content. \*(L"Defined as an administrator\*(R" means that a call to the
following will return true:
.PP
.Vb 1
\& my $is_admin = CTX\->request\->auth_is_admin;
.Ve
.SS "Global Configuration"
.IX Subsection "Global Configuration"
The following keys in your server configuration are used in caching:
.IP "\(bu" 4
\&\f(CW\*(C`cache.use\*(C'\fR: If set to true, content caching is enabled; if
set to false, it is disabled.
.IP "\(bu" 4
\&\f(CW\*(C`cache.cleanup\*(C'\fR: If true we delete and recreate the cache directory
every time the server starts up. This is recommended unless you're
sure what's being cached and for how long.
.IP "\(bu" 4
\&\f(CW\*(C`cache.class\*(C'\fR: Cache implementation to use.  Currently only
OpenInteract2::Cache::File is supported.
.IP "\(bu" 4
\&\f(CW\*(C`cache.directory\*(C'\fR: The directory where we put the cached
content. This is normally \f(CW\*(C`$WEBSITE_DIR/cache/content\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`cache.default_expire\*(C'\fR: number of seconds used for the cached content
expiration. You can override this on a case-by-case basis.
.IP "\(bu" 4
\&\f(CW\*(C`cache.max_size\*(C'\fR: Max size the cache should be allowed to
grow, in bytes.
.IP "\(bu" 4
\&\f(CW\*(C`cache.directory_depth\*(C'\fR: If you find that retrieving cached
content is slow because of the number of items in a particular
directory, increase this number.
.SS "Content Caching Requirements"
.IX Subsection "Content Caching Requirements"
There is really only one requirement for enabling caching. Well,
two. The first (or zeroth) is that you must subclass
OpenInteract2::Action. You almost certainly
already do this, so it's not much of a requirement.
.PP
The real requirement: caching must be configured in your action using
the parameter \f(CW\*(C`cache_param\*(C'\fR and, optionally, \f(CW\*(C`cache_expire\*(C'\fR.
.PP
We need to ensure that we can uniquely identify each request for
content. Generally this is done by associating a unique key with each
different set of dynamic content. We create this unique key by
combining the task with a number of action parameters and their
values.
.SS "Creating a Unique Cache Key"
.IX Subsection "Creating a Unique Cache Key"
For instance, in the 'news' action you have a 'latest' task. This
brings up the latest n news items. You'd want the cached data to
reflect this number so you set it in the \f(CW\*(C`cache_param\*(C'\fR section of the
action. Here's an example:
.PP
.Vb 2
\& [news cache_param]
\& latest     = num_items
.Ve
.PP
Here we've told the caching system to associate content from the
\&'latest' task with the variable 'num_items'. So when we get a request:
.PP
.Vb 1
\& /news/latest/?num_items=10
.Ve
.PP
We'll create a unique cache key like the following:
.PP
.Vb 1
\& news;latest;num_items=10
.Ve
.PP
and use this to get and set the cached content. (The actual key may
not look like this, it's just an example.)
.PP
You can also associate multiple parameters with a task. For instance,
say we also used a variable 'country' to further specify which latest
news items are retrieved:
.PP
.Vb 3
\& [news cache_param]
\& latest     = num_items
\& latest     = country
.Ve
.PP
And a corresponding key might look like:
.PP
.Vb 1
\& news;latest;country=USA;num_items=10
.Ve
.PP
Now the cached content depends on 'num_items' and 'country'. All of
these requests would cache their content to different places and
remain totally separate from one another:
.PP
.Vb 5
\& /news/latest/?num_items=10
\& /news/latest/?num_items=15
\& /news/latest/?num_items=10&country=USA
\& /news/latest/?num_items=10&country=France
\& /news/latest/?num_items=15&country=USA
.Ve
.SS "Controlling Cache Expirations"
.IX Subsection "Controlling Cache Expirations"
You can also control when cached content expires using the
\&\f(CW\*(C`cache_expire\*(C'\fR section of the action:
.PP
.Vb 4
\& [news cache_expire]
\& latest     = 600
\& display    = 1h
\& home       = 10m
.Ve
.PP
Unadorned values, such as 'latest' are in seconds. You can also use a
character after the number to indicate minutes (m), hours (h) or days
(d). Here we've said the content generated by the 'latest' and 'home'
tasks should be cached for 10 minutes, and the 'display' task for one
hour. You can manually delete cache entries using the \f(CW\*(C`clear_cache()\*(C'\fR
action method.
.PP
Notice that we included an extra task here, 'home'. It has no
dependencies on any parameters so we don't need to specify any in
\&\f(CW\*(C`cache_param\*(C'\fR.
.PP
If you don't list your task in \f(CW\*(C`cache_expire\*(C'\fR content generated by it
will not be cached unless tell \s-1OI\s0 you want the same value to be
applied to all tasks. For this you just assign a single value to
\&'cache_expire':
.PP
.Vb 4
\& [news]
\& class = OpenInteract2::Action::News
\& ...
\& cache_expire = 10m
.Ve
.PP
This tells \s-1OI\s0 to use a cache expiration of 10 minutes for all tasks in
the 'news' action.
.SS "Specifying Cache Parameters"
.IX Subsection "Specifying Cache Parameters"
The \f(CW\*(C`execute\*(C'\fR method of
OpenInteract2::Action takes care of this for
you. The only aspect you need to be aware of is setting up your
parameters for the cache key. Before \f(CW\*(C`execute()\*(C'\fR checks the cache it
makes a call to \f(CW\*(C`initialize_cache_params()\*(C'\fR. This allows you the
chance to return parameter values that will determine the cache
key. It's useful to specify values that might be the combination of
several request parameters (like a date) or a parameter that doesn't
normally vary by request (like the day of the week).
.PP
Much of the time, however, you won't need to set any additional
parameters. Normally you'll depend on \s-1GET/POST\s0 parameters passed from
the user. We already have access to those through the
OpenInteract2::Request object, so we go ahead and use them if
necessary.
.PP
Additionally there are a couple of implicit parameters you can use to
segment your cache entries:
.IP "\(bu" 4
\&\fBuser_id\fR: \s-1ID\s0 of the current user
.IP "\(bu" 4
\&\fBtheme_id\fR: \s-1ID\s0 of the current theme
.PP
If you specify any of these a reasonable default is supplied.
.PP
So to find a value we check, in order and taking the first defined
value:
.IP "1." 4
Return value from \f(CW\*(C`initialize_cache_params()\*(C'\fR
.IP "2." 4
Value of parameter in action
.IP "3." 4
Value of parameter in request
.IP "4." 4
Default value if an implicit parameter.
.PP
For instance, in the above example we specified the parameters for the
\&'display' task as 'news_id'. If this were passed in via the request
we'd don't have to change our 'display' task at all to use
caching. Even if the task is called programmatically by another action
we won't have to change it since the 'news_id' can be set via the
action parameter.
.PP
Ah, but what happens if someone passes in a news object directly?
.PP
.Vb 9
\& sub _calling_display_task {
\&     my ( $self ) = @_;
\&     my $fakenews = $self\->_create_news_object( type => \*(Aqonion\*(Aq );
\&     my $display_action = CTX\->lookup_action( \*(Aqnews\*(Aq );
\&     return $display_action\->execute({
\&         task => \*(Aqdisplay\*(Aq,
\&         news => $fakenews
\&     });
\& }
.Ve
.PP
Now our automatic parameter discovery won't work. This is where the
\&\f(CW\*(C`initialize_cache_params()\*(C'\fR comes in handy. In our 'news' action we
can have:
.PP
.Vb 8
\& sub initialize_cache_params {
\&     my ( $self ) = @_;
\&     my %params = ();
\&     if ( my $news = $self\->param( \*(Aqnews\*(Aq ) ) {
\&         $params{news_id} = $news\->id;
\&     }
\&     return \e%params;
\& }
.Ve
.PP
And everything will work!
.SS "Clearing the Cache"
.IX Subsection "Clearing the Cache"
You have the option of clearing the cache whenever you manipulate data.
For instance, if you edit the title of a news story you do not want the
old title to appear in the story listing. And if you delete a story and
mark it as inactive because it's inappropriate, you do not want it in
your headline listing.
.PP
So whenever you modify data, it's normally best to call
\&\f(CW\*(C`clear_cache()\*(C'\fR. This method is inherited from
OpenInteract2::Action like the others. Here's
an example:
.PP
.Vb 10
\& sub update {
\&     my ( $self ) = @_;
\&     my $request = CTX\->request;
\&     my $thingy_id = $self\->param( \*(Aqthingy_id\*(Aq )
\&                     || $request\->param( \*(Aqthingy_id\*(Aq );
\&     my $thingy = eval {
\&         CTX\->lookup_object( \*(Aqthingy\*(Aq )\->fetch( $thingy_id );
\&     };
\&     if ( $@ ) { ... }
\&     $thingy\->{foo} = $request\->param( \*(Aqfoo\*(Aq );
\&     eval { $thingy\->save };
\&     if ( $@ ) {
\&         $self\->param_add( error_msg => "Cannot save thingy: $@" );
\&         return $self\->execute({
\&             task   => \*(Aqdisplay_form\*(Aq,
\&             thingy => $thingy
\&         });
\&     }
\&     else {
\&         $self\->clear_cache();
\&         $self\->param_add({ status_msg => "Thingy updated ok" });
\&         return $self\->execute({ task => \*(Aqlist\*(Aq });
\&     }
\& }
.Ve
.PP
So when the 'list' method is called after a successful \f(CW\*(C`update()\*(C'\fR on
the object, the previously cached content will have been deleted and
the content will be regenerated anew.
.SS "Filtering Cached Content"
.IX Subsection "Filtering Cached Content"
As mentioned in OpenInteract2::Action under 'Built\-In
Observations', the base action class filters content \fBbefore\fR it's
cached. So when you pull up cached content you're seeing the effects
of those filters.
.PP
Action observers also have an opportunity to modify or react to cached
content. Whenever OpenInteract2::Action gets a cache hit it issues
an observation 'cache hit'. Your observer can listen for this and
modify the content (since it's passed as a scalar reference) as
necessary:
.PP
.Vb 6
\& # Translate all upper\-case "PERL" references to "Perl"
\& sub update {
\&     my ( $class, $action, $type, $content ) = @_;
\&     return unless ( $type eq \*(Aqcache hit\*(Aq );
\&     $$content =~ s/PERL/Perl/g;
\& }
.Ve
.SH "TEMPLATE CACHING"
.IX Header "TEMPLATE CACHING"
This section discusses what the preferred templating engine (Template
Toolkit) does and how it's handled in OpenInteract. Your engine may
handle it differently.
.SS "Caching \s-1TT\s0 Templates"
.IX Subsection "Caching TT Templates"
Instead of parsing a template every time you request it, the Template
Toolkit (\s-1TT\s0) will translate the template to Perl code and, if allowed,
cache it in memory. Keeping templates in memory will make your website
much faster.
.PP
\&\s-1TT\s0 will also save your compiled template to the filesystem. This is
useful for successive starts of your website \*(-- if the template if
found in the compile directory \s-1TT\s0 doesn't need to parse it again, even
though you've stopped and restarted your server since it was first
read.
.SS "Configuration"
.IX Subsection "Configuration"
The following keys from your server configuration control caching and
compiling:
.IP "\(bu" 4
\&\f(CW\*(C`content_generator.TT.cache_size\*(C'\fR: This is the main parameter, describing
how many cached templates \s-1TT\s0 will hold in memory. The only restriction
on a high value is your memory, so experiment with as high a number as
possible.
.Sp
If you set this to 0 then caching will be disabled. This is useful
when you're doing debugging on your site, but it can make things
noticably slower if you have lots of requests. (Note: 'lots' means
\&'more than a handful'.)
.IP "\(bu" 4
\&\f(CW\*(C`content_generator.TT.cache_expire\*(C'\fR: Sets the expiration (in seconds)
for how long the templates remain cached in memory before they're
reparsed.
.IP "\(bu" 4
\&\f(CW\*(C`content_generator.TT.compile_dir\*(C'\fR: The directory where we store the
compiled templates in the filesystem. This is normally \f(CW\*(C`cache/tt\*(C'\fR,
which gets resolved at runtime to \f(CW\*(C`$WEBSITE_DIR/cache/tt\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`content_generator.TT.compile_ext\*(C'\fR: Extension of the file created when the
template is compiled to the filesystem.
.IP "\(bu" 4
\&\f(CW\*(C`content_generator.TT.compile_cleanup\*(C'\fR: If set to a true value, we
clean out the template compile directory when the Apache server starts
up.
.PP
That's it! You can monitor the process of template caching by setting
the \f(CW\*(C`OI2.TEMPLATE\*(C'\fR logging key to '\s-1DEBUG\s0':
.PP
.Vb 2
\& Old value:
\&  log4perl.logger.OI2.TEMPLATE   = WARN
\& 
\& New value:
\&  log4perl.logger.OI2.TEMPLATE   = DEBUG
.Ve
.PP
Be warned: this produces a prodigious amount of messages.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2005 Chris Winters. All rights reserved.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
