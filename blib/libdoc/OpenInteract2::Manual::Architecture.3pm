.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Manual::Architecture 3"
.TH OpenInteract2::Manual::Architecture 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Manual::Architecture \- Overview of the OpenInteract2 Architecture
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This part of the OpenInteract2 manual describes the major pieces of
the system and traces a users's request from catching the \s-1URL\s0 to
returning the content.
.SH "USING MVC LINGO"
.IX Header "USING MVC LINGO"
In case you've been hiding under a rock, \s-1MVC\s0 stands for
\&\fBM\fRodel\-\fBV\fRiew\-\fBC\fRontroller. It's a method of separating the
different concerns of your application for flexibility and other
reasons. While too broad to be a pattern it's still extremely useful
to keep in mind as you're developing.
.PP
\&\s-1MVC\s0 was developed in Smalltalk and targeted at desktop
applications. It's meant to decouple the various graphical widgets
from the actions resulting from them. While some have argued that \s-1MVC\s0
isn't appropriate for web applications (see link to Andy Wardley's
discussion in \*(L"\s-1SEE\s0 \s-1ALSO\s0\*(R"), it's still useful to categorize how the
different pieces of the application are separated.
.SS "Model"
.IX Subsection "Model"
This is the smarts of your application and, unless you're a graphic
designer, probably the area on which you'll spend the most time. The
model consists of your application's core objects and processes. The
objects are normally persistent. So the model for a shopping cart
application may consist of the products in the cart (persistent), the
cart itself (semi-persistent), the customer (persistent), different
payment types (persistent) and the order process (transient).
.PP
Generally we use relational databases for persistence, but this also
encompasses other storage technologies (\s-1LDAP\s0, \s-1GDBM\s0, \s-1CSV\s0, etc.).
.PP
In OpenInteract you most often use \s-1SPOPS\s0 to represent your
application's state as persistable objects. There are many hooks for
initializing \s-1SPOPS\s0 classes and adding useful behaviors to the
objects. But \s-1OI\s0 doesn't require that you use \s-1SPOPS\s0 for everything \*(--
you can easily use another \s-1CPAN\s0 module (like Class::DBI)
for your model.
.PP
The processes are normally represented as Action objects, although
they may be generic enough to be a normal perl object that's
instantiated by an Action. To use the hackneyed shopping cart example:
the order process would probably be a separate object (e.g.,
\&'OpenInteract2::OrderProcess') so you can use it from a web action and
in response to emails or some other input
.SS "View"
.IX Subsection "View"
The view is what the user sees of your application. The view and model
communicate in a fairly limited but flexible fashion. In the \s-1GUI\s0 world
a typical \s-1MVC\s0 example would be a spreadsheet: one view is of tabular
data, another view is a pie chart, another view is a line chart. The
model stays the same, the view changes.
.PP
A typical web application view is a template with some sort of
processing engine behind it. The template takes some sort of data
structure and extracts the necessary information to display it to the
user.
.PP
\&\s-1OI\s0 is fairly flexible about views. The model (Action) always returns
content. Generally the Action will collect data, do some sort of
validation on it and then pass it on to the Content Generator along
with the name of a view. But the Action can also decide to return the
content itself. (This is unusual but has its place.)
.PP
The view name corresponds to a template file somewhere in a
package. So the view 'mypkg::foo' would refer to a file with a name
like \f(CW\*(C`$WEBSITE_DIR/pkg/mypkg\-x.xx/template/foo\*(C'\fR. And the Content
Generator is reponsible for taking the data from the model and passing
it to the view so it can be processed. The model doesn't care how the
data are used and the view doesn't care from where the data came.
.SS "Controller"
.IX Subsection "Controller"
Also known as a dispatcher, this uses a utility (ActionResolver) to
decide which model (Action) is called and how to represent the data
from the outside world. These are represented by the Controller object
which dispatches the user's request, the Request object which takes
the user's inputs (however they arrive) and translates them to a
standard format, and the Response object which translates the work
done during the request cycle into something the user can understand.
.PP
For a web application:
.IP "\(bu" 4
The Request will store the \s-1URL\s0 requested, pull out useful information
from the headers and network information, and parse the \s-1GET/POST\s0
request into parameters and file uploads.
.IP "\(bu" 4
The Controller hands the \s-1URL\s0 off to the ActionResolver, which
instantiates a number of small objects in a chain of
responsibility. It then asks each if it's able to create an action
from the given \s-1URL\s0. Once created the Controller executes the Action,
capturing its output. It doesn't care what the Action does or how the
Action does it. The Controller will also place this Action's output in
a larger context (e.g., as part of a larger web page) as necessary.
.IP "\(bu" 4
The Response returns the content along with any necessary headers to
the user.
.SH "OI METADATA: CONTEXT"
.IX Header "OI METADATA: CONTEXT"
.SS "Overview"
.IX Subsection "Overview"
The Context (abbrev: \s-1CTX\s0) glues the system together so you'll see it a
lot.It holds all application configuration information and provides a
central lookup mechanism for actions, content generators, controllers
and \s-1SPOPS\s0 object classes.
.PP
It is a singleton (there's only one in the system at any time) and you
can import this singleton reference from the
OpenInteract2::Context class.
.SS "Creating the Context"
.IX Subsection "Creating the Context"
Creating the context is one of the first actions you take when
starting an \s-1OI2\s0 server. While it can be created without referencing a
website it's not much use if you don't. (You should only need do this
when bootstrapping a new website into existence, and this is already
done for you in
OpenInteract2::Manage::Website::Create.)
.PP
So normally it looks something like this:
.PP
.Vb 3
\& my $ctx = OpenInteract2::Context\->create({
\&     website_dir => $website_dir
\& });
.Ve
.PP
Once it's created the \f(CW\*(C`CTX\*(C'\fR symbol from OpenInteract2::Context can
be imported and used anywhere, like this:
.PP
.Vb 1
\& use OpenInteract2::Context qw( CTX );
\& 
\& sub foo {
\&     my ( $self ) = @_;
\&     my $login_info = CTX\->lookup_login_config;
\&     ...
\& }
.Ve
.SH "ADAPTER"
.IX Header "ADAPTER"
.SS "Overview"
.IX Subsection "Overview"
The job of the adapter is to translate the world's information to
something understandable by OpenInteract and then translate what
OpenInteract generates into information for the outside world. So it
sits between your interface (e.g., Apache/mod_perl, \s-1CGI\s0, etc.) and the
OpenInteract server. The information it translates from the outside
world includes parameters from the user, user authentication,
information about the request (hostname, \s-1URL\s0, referer, cookies, etc.)
and other data. It places these data into the relevant
OpenInteract2::Request subclass.
.PP
Once the OpenInteract cycle is complete the adapter translates
OpenInteract data (content, headers, etc.) into a response to send
back to the user via the relevant
OpenInteract2::Response subclass. For an
example see Apache::OpenInteract2.
.SS "Creating your own adapter"
.IX Subsection "Creating your own adapter"
Creating an adapter is not difficult. Adapter classes tend to be
fairly short as most of the work is done in in the
OpenInteract2::Request and
OpenInteract2::Response subclasses. For
instance, here's the full adapter for Apache/mod_perl 1.x:
.PP
.Vb 1
\& package Apache::OpenInteract2;
\& 
\& use strict;
\& use Log::Log4perl            qw( get_logger );
\& use OpenInteract2::Auth;
\& use OpenInteract2::Constants qw( :log );
\& use OpenInteract2::Context   qw( CTX );
\& use OpenInteract2::Request;
\& use OpenInteract2::Response;
\& 
\& sub handler($$) {
\&     my ( $class, $r ) = @_;
\&     my $log = get_logger( LOG_OI );
\& 
\&     $log\->is_info &&
\&         $log\->info( scalar( localtime ), ": request from ",
\&                     "[", $r\->connection\->remote_ip, "] for URL ",
\&                     "[", $r\->uri, \*(Aq?\*(Aq, scalar( $r\->args ), "]" );
\& 
\&     my $response = OpenInteract2::Response\->new({ apache => $r });
\&     my $request  = OpenInteract2::Request\->new({ apache => $r });
\& 
\&     OpenInteract2::Auth\->login( $r\->pnotes( \*(Aqlogin_user\*(Aq ) );
\& 
\&     my $controller = eval {
\&         OpenInteract2::Controller\->new( $request, $response )
\&     };
\&     if ( $@ ) {
\&         $response\->content( $@ );
\&     }
\&     else {
\&         $controller\->execute;
\&     }
\&     $response\->send;
\&     return $response\->status;
\& }
\& 
\& 1;
.Ve
.PP
Very easy \*(-- it's only about 15 lines if you remove the logging! This
even has a little twist by passing in the 'login_user' key from the
Apache \f(CW\*(C`pnotes\*(C'\fR (line 23), which is a hook to the
Apache::OpenInteract2::HttpAuth
class to allow \s-1HTTP\s0 (rather than cookie) authentication.
.PP
Some gotchas to note:
.IP "\(bu" 4
\&\fBTell \s-1OI2\s0 what adapter you are\fR
.Sp
Either at server startup or the first time your adapter processes a
request you must tell \s-1OI2\s0 what type of adapter you are. This is very
simple, just two method calls on the OpenInteract2::Context
object. Here's an example where we do it outside the adapter itself in
the Apache 1.x \f(CW\*(C`startup.pl\*(C'\fR file:
.Sp
.Vb 2
\& # Create the context...
\& my $ctx = OpenInteract2::Context\->create( $bootstrap );
\& 
\& # ...let the context know what type of adapter we are
\& $ctx\->assign_request_type( \*(Aqapache\*(Aq );
\& $ctx\->assign_response_type( \*(Aqapache\*(Aq );
.Ve
.Sp
Here's one where we do it inside the adapter for a \s-1CGI\s0 process:
.Sp
.Vb 5
\& my $ctx = OpenInteract2::Context\->create({
\&     website_dir => $website_dir
\& });
\& $ctx\->assign_request_type( \*(Aqcgi\*(Aq );
\& $ctx\->assign_response_type( \*(Aqcgi\*(Aq );
.Ve
.Sp
The currently available adapter types, all listed in the 'request' and
\&'response' server configuration keys, are:
.RS 4
.IP "\(bu" 4
\&\fBapache\fR: For Apache/mod_perl 1.x
.IP "\(bu" 4
\&\fBapache2\fR: For Apache/mod_perl 2.x
.IP "\(bu" 4
\&\fBcgi\fR: For \s-1CGI\s0 processes; also usable under FastCGI (see the script
\&\f(CW\*(C`cgi\-bin/oi2.fcgi\*(C'\fR for the easy setup).
.IP "\(bu" 4
\&\fBlwp\fR: For running inside a \s-1LWP\s0 server
.IP "\(bu" 4
\&\fBstandalone\fR: For setting everything up yourself, which means that it
could in theory run inside an \s-1SMTP\s0 daemon, \s-1FTP\s0 server, etc.
.RE
.RS 4
.Sp
You can add a new request/response type in two ways. The easiest is
just to add the request/response type and class to the server
configuration:
.Sp
.Vb 3
\& [request]
\& ...
\& myenv = OpenInteract2::Request::MyEnvironment
\& 
\& [response]
\& ...
\& myenv = OpenInteract2::Response::MyEnvironment
.Ve
.Sp
You can also programmatically register the adapters in your server startup :
.Sp
.Vb 2
\& OpenInteract2::Request\->register_factory_type(
\&         myenv => \*(AqOpenInteract2::Request::MyEnvironment\*(Aq );
\& 
\& OpenInteract2::Response\->register_factory_type(
\&         myenv => \*(AqOpenInteract2::Response::MyEnvironment\*(Aq );
.Ve
.Sp
No matter which you choose, all calls to 'assign_request_type' and
\&'assign_response_type' will have 'myenv' available.
.RE
.IP "\(bu" 4
\&\fBCreate response before request\fR \- It may seem backwards but you need
to create the response object before the request object. (This is due
to a dependency.)
.PP
If your adapter is more of a standalone service (like the
\&\f(CW\*(C`oi2_daemon\*(C'\fR) that spawns off children/threads for requests, you also
need to also be aware of the following:
.IP "\(bu" 4
\&\fBInitialize logging\fR \- You'll need to initialize log4perl. This is
normally as simple as passing a parameter to the \f(CW\*(C`create\*(C'\fR method of
OpenInteract2::Context, but you can also use
one of the methods in OpenInteract2::Log.
.IP "\(bu" 4
\&\fBClose all database connections\fR \- Before spawning off
children/threads from the parent you \fB\s-1MUST\s0\fR shutdown all database
connections. They won't survive the fork/thread and you'll get very
strange errors. Do this with the \f(CW\*(C`shutdown\*(C'\fR method in
OpenInteract2::DatasourceManager.
.SH "CONTROLLER"
.IX Header "CONTROLLER"
.SS "Overview"
.IX Subsection "Overview"
Once the adapter has created the request and response it hands off the
processing to the
OpenInteract2::Controller object. Now
we're entirely inside the \s-1OI2\s0 server environment. Its main
responsibility is to match up the \s-1URL\s0 with an OpenInteract2::Action
object and execute it, returning its generate content to the browser.
.PP
To match up the \s-1URL\s0 with the Action we use a chain of responsibility
pattern, organized by OpenInteract2::ActionResolver. Children
classes under this namespace are \f(CW\*(C`require\*(C'\fRd at server startup. So for
each request the main ActionResolver class will instantiate all its
children and pass each the OpenInteract2::Request object and
\&\s-1URL\s0. Each child can decide to match up the \s-1URL\s0 with an
OpenInteract2::Action object or do nothing.
.PP
The ActionResolvers shipped with the system can respond to:
.IP "\fBuser directory requests\fR" 4
.IX Item "user directory requests"
So something like \f(CW\*(C`http://foo.com/~lucyliu/\*(C'\fR will get recognized by
this resolver and matched to a user action. A successive item in the
\&\s-1URL\s0 (e.g., '/~lucyliu/profile/') will get assigned as the action's
task.
.IP "\fBname from \s-1URL\s0\fR" 4
.IX Item "name from URL"
This will get used most often \*(-- from something like
\&\f(CW\*(C`http://foo.com/news/latest/\*(C'\fR it finds the name ('news') and tries to
lookup an action based on it. If found it also assigns the next item
in the \s-1URL\s0 as the action's task.
.IP "\fBaction not found or action missing\fR" 4
.IX Item "action not found or action missing"
If the name in the \s-1URL\s0 wasn't matched to a \s-1URL\s0 we assign it to the
\&'not found' action. This is a catch-all action and very useful if you
want to map what look like simple page requests to an
OpenInteract2::Action object. By default we use the 'page' action.
.Sp
And if there was no action in the \s-1URL\s0 (e.g., \f(CW\*(C`http://foo.com/\*(C'\fR) we
invoke the 'none' action. This also uses the 'page' action.
.PP
Once the action's found we call \f(CW\*(C`execute()\*(C'\fR on it, which generates
its content. The most-used controller
(OpenInteract2::Controller::MainTemplate)
places that generated content in a larger scope so you can control
common graphical elements (sidebars, menus, etc.) from once
place. Another controller
(OpenInteract2::Controller::Raw)
returns the content as-is.
.SH "ACTION"
.IX Header "ACTION"
.SS "Overview"
.IX Subsection "Overview"
Actions are the core of OpenInteract2. Each action provides a discrete
set of functionality. What \*(L"discrete set\*(R" means is up to the
developer, but typically this is a set of \s-1CRUDS\s0 (CReate \- Update \-
Delete \- Search) operations on a class of objects.
.PP
Each action is represented by zero or more URLs, and each operation is
specified by a task referenced in that \s-1URL\s0. So if I created a 'news'
action my URLs might look like:
.PP
.Vb 4
\& http://foo.com/news/
\& http://foo.com/news/display/
\& http://foo.com/news/search_form/
\& http://foo.com/news/search/
.Ve
.PP
Every task returns some sort of content, generally by passing data to
a Content Generator which marries it with a template. See
OpenInteract2::Action for much more
information.
.SH "CONTENT GENERATOR"
.IX Header "CONTENT GENERATOR"
.SS "Overview"
.IX Subsection "Overview"
As mentioned above tasks in an Action return content. They normally
generate that content by assembling a set of data and passing that
data off to a content generator. A content generator is a wrapper
around some sort of templating system, such as the Template, HTML::Template or
Text::Template or even your own homegrown
system. (Admit it, you've written your own.)
.PP
Each action is associated with a content generator. And you can even
associate an action with multiple content generators so you can settle
a bet as to which templating system is easiest to use.
.SH "TRACING A REQUEST"
.IX Header "TRACING A REQUEST"
Now we'll trace a request throughout OpenInteract.
.SS "Step 0: Startup Tasks"
.IX Subsection "Step 0: Startup Tasks"
The adapter or another process (e.g., 'startup.pl' in a mod_perl
setup) will run a number of tasks at server startup. This includes:
.IP "\(bu" 4
Initialize logging
.IP "\(bu" 4
Create context with website directory
.IP "\(bu" 4
Assign the proper request/response types to request
.IP "\(bu" 4
If threaded/forking: disconnect all database handles.
.SS "Step 1: User Request Meets Adapter"
.IX Subsection "Step 1: User Request Meets Adapter"
This step is a little fuzzy by necessity: we purposefully don't know
in what form the request is coming in or how the adapter handles it.
.PP
If you're running a web server the typical user request is coming over
\&\s-1HTTP\s0 from a browser, feed reader, bot or some other client.
.SS "Step 2: Adapter Creates Request/Response Objects"
.IX Subsection "Step 2: Adapter Creates Request/Response Objects"
The adapter creates the
OpenInteract2::Response and
OpenInteract2::Request objects, in that
order. Each one has necessary initialization steps done behind the
scenes when you create it. In particular the request object will read
the necessary headers, parameters, uploaded files, cookies and create
the session from the cookie.
.PP
It also finds the 'relevant' part of the \s-1URL\s0 and determines the action
and task from it. The 'relevant' part is what's leftover after the
URL-space (aka, deployment context, set in the
\&\f(CW\*(C`context_info.deployed_under\*(C'\fR server configuration key) is lopped off.
.SS "Step 3: Adapter Logs in User"
.IX Subsection "Step 3: Adapter Logs in User"
It can optionally handle extra authentication as this point such as
\&\s-1HTTP\s0 auth or some other capability. Generally this will consist of
retrieving a user object created from some other part of the system or
creating a user object based on trusted information (like a user \s-1ID\s0)
from another area.
.PP
If available this user object is passed to the \f(CW\*(C`login\*(C'\fR method of the
OpenInteract2::Auth class so it has a head
start.
.SS "Step 4: Adapter Creates Controller"
.IX Subsection "Step 4: Adapter Creates Controller"
Adapter creates the
OpenInteract2::Controller object with the
request and response objects created earlier.
.PP
The controller invokes a chain of responsibility provided by
OpenInteract2::ActionResolver to figure out what action to create
based on the \s-1URL\s0.
.SS "Step 5: Adapter Executes Controller"
.IX Subsection "Step 5: Adapter Executes Controller"
If the controller was created properly the adapter calls \f(CW\*(C`execute()\*(C'\fR
on it. This starts the content generation process running.
.PP
The controller will call \f(CW\*(C`execute()\*(C'\fR on the action which starts the
action's content generation process.
.PP
If the controller was not created properly it threw an exception which
we return as content.
.SS "Step 6: Action Finds Task"
.IX Subsection "Step 6: Action Finds Task"
The action needs to find which task to execute. Normally this is as
simple as getting the value of the \f(CW\*(C`task\*(C'\fR property. But the
individual action can override this, or if no task was specified we
use the value of \f(CW\*(C`task_default\*(C'\fR.
.SS "Step 7: Action Checks Validity"
.IX Subsection "Step 7: Action Checks Validity"
Find out if the task is invalid. A valid task:
.IP "\(bu" 4
Does not start with a '_'
.IP "\(bu" 4
Is not listed in \f(CW\*(C`task_invalid\*(C'\fR
.IP "\(bu" 4
Is listed among the tasks in \f(CW\*(C`task_valid\*(C'\fR if that property is
defined.
.PP
If the task is valid we also ensure that this user has the proper
security level to execute it.
.SS "Step 8: Action Generates Content"
.IX Subsection "Step 8: Action Generates Content"
First, we check the cache to see if content exists and if it does, we
return it without going any further.
.PP
Next we execute the method specified by what we've determined to be
the task. (This is almost certainly the method with the same name as
the task.)
.PP
An action can generate content by itself but most times it just
gathers the necessary data and passes it, along with a template
specification, to a content generator which returns the content for
the action.
.PP
If any observers are registered with the action they receive a
\&'filter' observation. Any of these observers can modify the content
we've just generated.
.PP
If the cache is activated for this method we'll cache the content. In
any case we return the content, finishing the flow for the action and
moving back up to the controller.
.SS "Step 9: Controller Places Action Content in Larger Scope (optional)"
.IX Subsection "Step 9: Controller Places Action Content in Larger Scope (optional)"
The main action is done and has returned its content to the
controller. One controller
(OpenInteract2::Controller::Raw)
will just return this content and call it a day.
.PP
Most times you'll want to take that content and put it into another
template. The controller just instantiates a new content generator and
goes through the same process as the action, passing it a set of data
(of which the generated action content is part) and a template
specification (normally from the 'main_template' theme property).
.PP
Oftentimes the main template will hold multiple discrete actions of
its own. For example, the default main template shipped with \s-1OI\s0 has an
action to generate the list of boxes that appears on the right-hand
side. You could trigger an action to get the latest weather
conditions, webcam photo, news headlines, whatever you wish.
.PP
Each of these actions is just like any other and goes through the same
process listed above.
.SS "Step 10: Controller Sets Content to Response"
.IX Subsection "Step 10: Controller Sets Content to Response"
Whether it's the action content or the scoped content (for lack of a
better name), we set the content in the response object, which hasn't
done much until now except hold the occasional outgoing cookie.
.PP
The controller's job is done and flow now returns back up a level to
the adapter.
.SS "Step 11: Adapter Asks Response to Send"
.IX Subsection "Step 11: Adapter Asks Response to Send"
The only job left of the adapter is to ask the response to send the
content.
.SS "Step 12: Adapter Cleans Up"
.IX Subsection "Step 12: Adapter Cleans Up"
The adapter can do any necessary cleanup.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Andy Wardley's email about \s-1MVC\s0 and web applications:
.PP
<http://lists.ourshack.com/pipermail/templates/2002\-November/003974.html>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2005 Chris Winters. All rights reserved.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
