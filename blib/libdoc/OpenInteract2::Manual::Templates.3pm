.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Manual::Templates 3"
.TH OpenInteract2::Manual::Templates 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Manual::Templates \- Using the Template Toolkit with OpenInteract2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This document reviews how the templating system works in
OpenInteract. Template processing is at the heart of OpenInteract, and
it is important to understand it well.
.PP
This document focuses on web applications and the Template Toolkit. If
other templating systems get implemented in OpenInteract we'll stick
pointers in here to those docs.
.SH "WHAT IS A TEMPLATE?"
.IX Header "WHAT IS A TEMPLATE?"
A template is simply \s-1HTML\s0 combined with directives meant for the
template processing engine. Here's an example:
.PP
.Vb 2
\& <p>Welcome back 
\&   <font color="red">[% OI.login.full_name %]</font>!</p>
.Ve
.PP
When run through the template processing engine with a normal user
object in the '\s-1OI\s0.login' key, this will result in:
.PP
.Vb 2
\& <p>Welcome back 
\&   <font color="red">Charlie Brown</font>!</p>
.Ve
.PP
So the information between the '[%' and ' %]' symbols
('\s-1OI\s0.login.full_name') was replaced by other text depending on the
user who was viewing the page. If another user viewed the page, she
might have seen:
.PP
.Vb 2
\& <p>Welcome back 
\&   <font color="red">Peppermint Patty</font>!</p>
.Ve
.PP
OpenInteract provides a number of tools for you in every template you
write (see
OpenInteract2::TT2::Plugin). However,
you can also provide your templates access to query results from the
various data stores that \s-1SPOPS\s0 provides.
.SH "CREATING YOUR OWN TEMPLATE"
.IX Header "CREATING YOUR OWN TEMPLATE"
The general strategy behind OpenInteract applications is a well-known
one: separate the display of data from how the data are retrieved or
operated on.
.PP
To this end the code behind an OpenInteract application normally just
retrieves some data using parameters supplied by the user and then
hands it off to the template. The template doesn't care how the data
were retrieved \*(-- it just knows what is supposed to be there. The
template and code enter into a sort of contract \*(-- the template
expects certain data which both the code and the system provide.
.PP
So, let's do an example. Let's say you want to display a list of users
who have accessed the system in the last n minutes. Your code might
have a subroutine like this:
.PP
.Vb 5
\& sub list_time_limit {
\&     my ( $self ) = @_;
\&     my $request = CTX\->request;
\&     my $time_limit = $self\->param( \*(Aqtime_limit\*(Aq )
\&                      || $request\->param( \*(Aqtime_limit\*(Aq );
\&
\&     # This SQL is Sybase\-specific, but should be clear
\&     my $where = \*(Aqdatediff( minute, last_access, getdate() ) <= 30\*(Aq;
\&
\&     # Note: \*(Aqfetch_group\*(Aq returns an arrayref of objects.
\&     my $user_class = CTX\->lookup_object( \*(Aquser\*(Aq );
\&     my $user_list = eval {
\&         $user_class\->fetch_group({
\&             where => $where,
\&             order => \*(Aqlast_access\*(Aq,
\&         })
\&     };
\&     my %params = (
\&         user_list  => $user_list,
\&         time_limit => $time_limit,
\&     );
\&     return $self\->generate_content(
\&                         \e%params, { name => \*(Aqmypkg::user_list\*(Aq } );
\& }
.Ve
.PP
(The actual code would have lots of good things like error checking,
but this is just an example.)
.PP
Note that we simply passed a hashref of variables to the method
\&\f(CW\*(C`generate_content()\*(C'\fR, which decides what template engine to use and
passes along some basic information about our action to the
template. What we did not say was how the variables we passed were to
be displayed.
.PP
And your template might look like:
.PP
.Vb 10
\& 1 : [%\- DEFAULT theme = OI.theme_properties \-%]
\& 2 : 
\& 3 : <h2>User Listing</h2>
\& 4 :
\& 5 : <p>Users with accesses in the last <b>[% time_limit %]</b> minutes.
\& 6 : 
\& 7 : <table border="0" cellpadding="4">
\& 8 : 
\& 9 : [% PROCESS header_row( [ \*(AqUsername\*(Aq, \*(AqFull Name\*(Aq, \*(AqLast Access\*(Aq ] ) %]
\& 10: 
\& 11: [% FOREACH user_object = user_list %]
\& 12:  <tr align="center" valign="middle">
\& 13:    <td>[% user_object.login_name %]</td>
\& 14:    <td>[% user_object.full_name %]</td>
\& 15:    <td>[% user_object.last_access %]</td>
\& 16:  </tr>
\& 17: [% END %]
\& 18:
\& 19: </table>
.Ve
.PP
There are a few things at work here:
.IP "1." 4
We're using the scalar variable 'time_limit'. Since this is a simple
scalar, we can just refer to it by name in the template as a variable
(line 5) and the contents of the variable will replace this directive.
.IP "2." 4
We loop through the variable 'user_list' which we passed to the
template. The \s-1FOREACH\s0 directive used in the template (line 11) is very
similar to the \f(CW\*(C`foreach\*(C'\fR loop in perl \*(-- for every thing in the list
\&'user_list', we assign that thing to the variable 'user_object' which
we can then use within the loop.
.Sp
Within the loop we use both properties of the user object
('login_name' and 'last_access', lines 12 and 14) and call a method on
the object ('full_name', line 13).
.Sp
One of the nice features of the Template Toolkit is that it treats
objects and hashrefs in much the same way, using the dot notation. So
\&'user_object.full_name' could transparently translate to either:
.Sp
.Vb 2
\& $user_object\->full_name()
\& $user_object\->{full_name}
.Ve
.Sp
Here we're using the 'user_object' variable (obviously) as an
object. But we could modify the perl code to instead get all the
information about the user and combine it with other information into
a hashref and feed it to the same template. If we were to do this, we
would not have to modify \fBa single line\fR of our template.
.IP "3." 4
We access the OpenInteract2 plugin ('\s-1OI\s0') and find the theme properties
from it ('\s-1OI\s0.theme_properties', line 1). These get assigned to a
variable so we can use it multiple times throughout the template
rather than calling the plugin every time.
.Sp
Note that we did not explicitly pass the plugin into the template via
the variable hashref, as we did in this example with the variables
\&'time_limit' and 'user_list'. Think of the '\s-1OI\s0' plugin as part of the
template environment. You can use it to access information about the
current user, the theme being used, various text manipulation
routines, and more. We talk about it more below, but the plugin is
well-documented in
OpenInteract2::TT2::Plugin.
.PP
Now, what if we wanted to change the display of the data? We could
replace the 'user_list' template with the following:
.PP
.Vb 1
\& <h2>User Listing</h2>
\& 
\& <p>Users with accesses in the last <b>[% time_limit %]</b> minutes.
\& 
\& <ul>
\& [% FOREACH user_object = user_list %]
\&  <li>[% user_object.full_name %] ([% user_object.login_name %])
\&       accessed the system at [% user_object.last_access %]</li>
\& [% END %]
\& </ul>
.Ve
.PP
If we did this, we would not have to change \fBa single line\fR of our
back-end code, since the \*(L"contract\*(R" between the action task and
template hasn't changed. This contract specifies that the task will
provide a list of user objects and a time limit to the template. Even
though the template uses these data somewhat differently now, the code
is isolated from this change and indeed never cares about it.
.PP
Similarly, our content output could be a \s-1PDF\s0 instead of an \s-1HTML\s0
page. Instead of calling the template processing engine, we pass the
data off to a separate process which formats it according to various
rules and creates a \s-1PDF\s0 to send to the user. Again, the backend code
does not need to be modified at all. We just need to change the action
configuration to specify this new method of generating content and
create whatever PDF-specific methods are to be used.
.SH "CREATING YOUR OWN TEMPLATE PLUGIN"
.IX Header "CREATING YOUR OWN TEMPLATE PLUGIN"
As noted above you can declare one or more plugins supported by your
package with the following syntax:
.PP
.Vb 2
\& template_plugin   MyPlugin    OpenInteract2::TT2Plugin::MyPlugin
\& template_plugin   OtherPlugin OpenInteract2::TT2Plugin::OtherPlugin
.Ve
.PP
(The class name is arbitrary, you do not need to put it under a
particular namespace to work. Just don't use
OpenInteract2::TT2::Plugin since that's
already taken!)
.PP
Package plugins created in this matter are made available in the
default template namespace under the plugin name \*(-- 'MyPlugin' and
\&'OtherPlugin' above. This means you don't have to use a '\s-1USE\s0'
statement to bring in your plugin, it's just there. For instance:
.PP
.Vb 1
\& [% MyPlugin.my_action( \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ) %]
.Ve
.PP
Note that this assumes your plugin is stateless \*(-- if not you will
need to call '\s-1USE\s0' with the necessary initialization data and
manipulate the return value as necessary.
.PP
Previously you needed to set this up in a customized variable
handler. That handler is still available but it is not necessary for
exposing your plugins.
.PP
One word of caution: name your plugin carefully! It's best to pick
something fairly unique and name it in \s-1ALL\s0 \s-1CAPS\s0 to prevent colliding
with a name the user might pass to the template.
.PP
If you're creating an application comprised of two or more packages
the best tactic is to consolidate all application actions under a
single plugin rather than have one per package. And since your
application will be named something fairly unique you probably won't
have to worry about naming collisions.
.PP
To see what plugins are instantiated and available run the
\&\f(CW\*(C`list_plugins\*(C'\fR method on the plugin shipped with OpenInteract:
.PP
.Vb 7
\& Plugins available: 
\& <ul>
\&   [% plugins = OI.show_all_plugins %] 
\&   [% FOREACH plugin_name = plugins.keys.sort %]
\&   <li>[% plugin_name %]: [% plugins.$plugin_name %]
\&   [% END %]
\& </ul>
.Ve
.SH "HOW DOES IT WORK"
.IX Header "HOW DOES IT WORK"
If you're curious about this, then you first need to understand how
OpenInteract actions work. See
OpenInteract2::Action for more information.
.SS "Content Generators"
.IX Subsection "Content Generators"
OpenInteract2 can support multiple types of templating engines, also
known as content generators. Each action specifies (in its metadata)
the templating engine that will process the data generated by the
action into usable content. This type can also be modified
programmatically by the action code itself.
.PP
The templating engines are setup in the server configuration using the
\&'content_generator' key. OpenInteract comes with at least three
content generators configured for you: '\s-1TT\s0' (Template Toolkit),
\&'HTMLTemplate' (HTML::Template) and 'TextTemplate' (Text::Template).
.PP
In practice, many sites will only have one content generator and one
template processor for the web content. But you might want to use a
different content generator when you're creating customized emails or
something similar.
.SS "Action code shields itself from content generator"
.IX Subsection "Action code shields itself from content generator"
As we mentioned above your action code has no direct contact with a
content generator. The action method \f(CW\*(C`generate_content()\*(C'\fR takes care
of this, choosing a generator and passing the given parameters (plus
one or two others) to the engine. This provides another means for us
to modify the content generated by the action without ever modifying
the action itself \*(-- very useful. (Filters are an example of this.)
.PP
In addition to that the action doesn't even need to specify the
\&\fBtemplate source\fR. We can declare that as well by adding the
following to our action configuration:
.PP
.Vb 2
\& [userlist template_source]
\& list_time_limit = mypkg::user_list
.Ve
.PP
The handler now doesn't even need to pass a template source, so the
\&\f(CW\*(C`return\*(C'\fR can be modified like this:
.PP
.Vb 5
\&     my %params = (
\&         user_list  => $user_list,
\&         time_limit => $time_limit,
\&     );
\&     return $self\->generate_content( \e%params );
.Ve
.PP
Now we can use the same action code with multiple template
sources. For instance, we could create a heavily table-driven site
that most people will see and one that uses very little layout for
visually impaired folks. Further, we'll assume that the actions for
visually impaired folks begin with a 'v_', so our action configuration
might look like:
.PP
.Vb 4
\& [timelimit]
\& class  = OpenInteract2::Action::UserList
\& method = list_time_limit
\& template_source = mypkg::userlist_normal
\& 
\& [v_timelimit]
\& class  = OpenInteract2::Action::UserList
\& method = list_time_limit
\& template_source = mypkg::userlist_plain
.Ve
.SS "Loading templates"
.IX Subsection "Loading templates"
Package templates are located in one or two places:
.IP "\(bu" 4
The package \f(CW\*(C`template/\*(C'\fR directory. These are the templates shipped
with the package. When you upgrade the package you get whatever
templates are distributed with the upgrade.
.IP "\(bu" 4
The site \f(CW\*(C`template/packagename/\*(C'\fR directory. These are templates
edited by you that will persist package upgrades. When you edit a
template with the browser interface it will automatically save your
modified templates here.
.PP
The
OpenInteract2::TT2::Provider
and OpenInteract2::SiteTemplate classes
take care of making the loading process transparent. So all you need
to do is request a template with the 'package\-name::template\-name'
syntax and the rest is done for you.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
OpenInteract2::TT2::Plugin
.PP
Template
.PP
Template::Manual
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2004 Chris Winters. All rights reserved.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <Chris@cwinters.com>
