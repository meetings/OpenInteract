.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Setup 3"
.TH OpenInteract2::Setup 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Setup \- Base/Factory class for setup actions in OpenInteract2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # NOTE: Most of this is done for you in OI2::Context, but...
\& 
\& # Run all setup actions:
\& OpenInteract2::Setup\->run_all_actions( $ctx );
\& 
\& # Run all setup actions, skipping one and its dependencies:
\& OpenInteract2::Setup\->run_all_actions( $ctx, \*(Aqread packages\*(Aq );
\& 
\& # Later, run \*(Aqread packages\*(Aq and its dependencies
\& OpenInteract2::Setup\->run_setup_for( \*(Aqread packages\*(Aq );
\&
\& # Create the setup action \*(Aqcreate temporary library\*(Aq and run it
\& my $ctx = OpenInteract2::Context\->instance;
\& my $setup = OpenInteract2::Setup\->new( \*(Aqcreate temporary library\*(Aq );
\& $setup\->run( $ctx )
\& 
\& # Find available setup actions
\& my @actions = OpenInteract2::Setup\->list_actions;
\& print "Available setup actions: ", join( "\en", sort @actions );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class has two functions. First, it acts as a coordinator for
groups of setup actions to be run. Second, it acts as a factory for
those setup actions.
.PP
Setup actions are individual tasks that get run when the server starts
up. (They may also be run when executing management tasks, or whenever
you create a OpenInteract2::Context object.) Each task is a
subclass of this one and should be quite focused in its job.
.PP
All setup actions are discovered at runtime \*(-- as long as your action
subclasses this one and is on \f(CW@INC\fR we'll find it. Once read in your
setup action is responsible for registering itself with this class,
typically done with this as the last executable line:
.PP
.Vb 1
\& OpenInteract2::Setup\->register_factory_type( get_name() => _\|_PACKAGE_\|_ );
.Ve
.PP
Every setup action is responsible for providing the following
information about itself:
.IP "\(bu" 4
\&\fBName\fR \- Every setup action has a name that must be returned by
\&\f(CW\*(C`get_name()\*(C'\fR.
.IP "\(bu" 4
\&\fBDependencies\fR \- Every setup action may depend on other actions so we
can determine the order in which to run them. It may declare these by
returning a list from \f(CW\*(C`get_dependencies()\*(C'\fR.
.PP
You can find all available setup actions like this:
.PP
.Vb 2
\& my @actions = OpenInteract2::Setup\->list_actions;
\& print "Available setup actions: ", join( "\en", sort @actions );
.Ve
.PP
Since we're using Class::Factory you can instantiate a setup action
with its name:
.PP
.Vb 1
\& my $setup = OpenInteract2::Setup\->new( \*(Aqread packages\*(Aq );
.Ve
.SH "COORDINATING METHODS"
.IX Header "COORDINATING METHODS"
\&\fB\f(BIlist_actions()\fB\fR
.PP
\&\fB\f(BIget_setup_dependencies()\fB\fR
.PP
\&\fBrun_all_actions( \f(CB$ctx\fB, [ \f(CB@action_names_to_skip\fB ] )\fR
.PP
\&\fBrun_setup_for( \f(CB$action_name\fB )\fR
.PP
\&\fBremove_skip_actions( \f(CB@action_names_to_skip\fB )\fR
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
To the outside world each setup action has a very simple lifecycle:
.PP
.Vb 2
\& my $setup = OpenInteract2::Setup\->new( \*(Aqread packages\*(Aq );
\& $setup\->run();
.Ve
.PP
When implementing a setup action you have a little more granularity.
.SS "Required methods"
.IX Subsection "Required methods"
\&\fB\f(BIget_name()\fB\fR
.PP
\&\fBexecute( \f(CB$ctx\fB )\fR
.SS "Optional methods"
.IX Subsection "Optional methods"
\&\fB\f(BIget_dependencies()\fB\fR
.PP
\&\fB\f(BIinit()\fB\fR
.PP
\&\fBsetup( \f(CB$ctx\fB )\fR
.PP
\&\fBexecute( \f(CB$ctx\fB )\fR
.PP
\&\fBtear_down( \f(CB$ctx\fB )\fR
.SS "Common functionality"
.IX Subsection "Common functionality"
See also OpenInteract2::ParamContainer for parameter manipulation
methods.
.PP
\&\fBnew( \f(CB$type\fB, \f(CB%params\fB )\fR
.PP
\&\fBrun( \f(CB$ctx\fB )\fR
.PP
\&\fB_read_ini( \f(CB$ini_file\fB )\fR
.PP
Reads in the configuration file and returns the resulting
OpenInteract2::Config::IniFile object. If we encounter an error we
log the error and return undef.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::Factory
.PP
OpenInteract2::Context
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
