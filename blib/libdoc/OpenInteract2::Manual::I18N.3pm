.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Manual::I18N 3"
.TH OpenInteract2::Manual::I18N 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Manual::I18N \- Internationalization in OpenInteract2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This part of the manual will describe i18n efforts in OpenInteract2,
how to create message bundles to distribute with your application, and
how you can customize the process.
.SH "CAVEATS"
.IX Header "CAVEATS"
I'm a newbie at i18n/l10n efforts. The main purpose is to find the
path I think most web applications will trod and make that as simple
as possible to navigate. The hooks in the framework to enable
localization should be sufficiently unobtrusive so as not to preclude
other efforts you may have in this area.
.PP
So if you have ideas about how things can be done better or more
flexibly, please join the openinteract-dev mailing list and chime
in. (See \*(L"\s-1SEE\s0 \s-1ALSO\s0\*(R" for more info on the mailing list.)
.SH "WRITING LOCALIZED APPLICATIONS"
.IX Header "WRITING LOCALIZED APPLICATIONS"
.SS "100% localization is hard"
.IX Subsection "100% localization is hard"
Localizing every aspect of your application is extremely
difficult. There are the easy things like translating words on the
screen, date/time formats and money. Then there are the tough things:
what does this shade of yellow mean in China versus Saudi Arabia? What
happens if someone reads this sequence of graphics from right-to-left
instead of left-to-right? And on and on for many more items you
couldn't have even thought up yet.
.PP
OpenInteract won't presume to take care of all these for you. Instead
we try to make the most common operations as simple as
possible. Hopefully that will be sufficient for your needs.
.SH "IDENTIFYING LANGUAGE TO USE"
.IX Header "IDENTIFYING LANGUAGE TO USE"
.SS "We have ways of learning about you..."
.IX Subsection "We have ways of learning about you..."
Ordered from most to least important, here's how we identify the
language to use for the current request. First match wins.
.IP "\(bu" 4
User logged in? Look in 'lang' user property
.IP "\(bu" 4
Language set in session?
.IP "\(bu" 4
Language in \s-1GET/POST\s0 params? ('oi_language')
.IP "\(bu" 4
Language passed by browser? (use as backup also...)
.IP "\(bu" 4
Customized identifiers (register in server.ini)
.SS "Custom language identifier"
.IX Subsection "Custom language identifier"
\&\s-1OI\s0 has more hooks than your favorite rock band, and this area is no
exception. During the request initialization process we identify all
the languages available for this request. Normally this means all the
languages for a particular user, but you can override it with \s-1GET/POST\s0
parameters or a setting in the session.
.PP
We also provide the means for you to step in and implement your own \*(--
you could parse it from the \s-1URL\s0, use Geo::IP, whatever. Just create
an observer for the controller (under
OpenInteract2::Observer::Controller) and wait for the 'action
assigned' observation which occurs every request:
.PP
.Vb 1
\& package OpenInteract2::Observer::Controller::LanguageId;
\& 
\& use Geo::IP;
\& use OpenInteract2::Context qw( CTX );
\& 
\& my $gi = Geo::IP\->new( GEOIP_STANDARD );
\& 
\& sub update {
\&     my ( $class, $controller, $type, $action ) = @_;
\&     return unless ( $type eq \*(Aqaction assigned\*(Aq );
\&     my $request = CTX\->request;
\&
\&     # get our new languages...
\&     my $country = $gi\->country_code_by_addr( $request\->remote_host );
\&     my @langs_from_country = $class\->_some_nifty_method( $country );
\& 
\&     # assign the new languages after the existing ones
\&     $request\->assign_languages( $request\->language(), @langs_from_country );
\& }
.Ve
.SH "SETTING UP LOCALIZAION IN YOUR PACKAGE"
.IX Header "SETTING UP LOCALIZAION IN YOUR PACKAGE"
.SS "Type #1: Message replacement"
.IX Subsection "Type #1: Message replacement"
This is the fairly simplistic means of using keys to represent blocks
of text. The key gets replaced by the text for whatever language the
current user is associated with. Here's an example: you setup your
music library search form like this:
.PP
.Vb 1
\& Artist: _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& 
\& Title:  _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& 
\& Year:   _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& 
\&                 <Search>
.Ve
.PP
And you'd like to localize this. Like all other problems dealing with
programming you just add a layer of abstraction, associating each
piece of text with a key, then associating text to that key for each
language (represented here by braces but that's not how they'd look in
the template):
.PP
.Vb 1
\& {search.artist}: _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& 
\& {search.title}:  _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& 
\& {search.year}:   _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& 
\&                 <{search.button}>
.Ve
.PP
Now you just have sets of data for each language:
.PP
.Vb 5
\& en:
\& search.artist = Artist
\& search.title  = Title
\& search.year   = Year
\& search.button = Search
\& 
\& es:
\& search.artist = Artista
\& search.title  = Titulo
\& search.year   = Ano
\& search.button = Hallazgo
\& ...
.Ve
.PP
When the page is rendered these keys get replaced by the associated
text. Fortunately Perl comes with libraries to make this happen fairly
painlessly. And a nice side-effect is that the message files are in a
sufficiently simple format that you can ship them off to someone else
and just plug them in your application when they're ready.
.PP
There's more about the messages and the file format below.
.SS "Type #2: Template negotation"
.IX Subsection "Type #2: Template negotation"
A second type of localization is template negotiation. Hopefully you
won't need to use it as often because it can require more
maintenance. Instead of replacing text in the template you replace the
entire template wholesale.
.PP
It works in much the same way, except instead of placing text in the
various language files you place template names under a particular
key. (The name is in the normal 'package::template' syntax.) And just
like invoking a template from your action you can do this in two ways:
.IP "1." 4
specify the template in your action
.IP "2." 4
specify the template in your action configuration
.PP
Here's a quick example of the first, passing the message key in your
action \f(CW\*(C`generate_content()\*(C'\fR call:
.PP
.Vb 7
\& sub mytask {
\&     my ( $self ) = @_
\&     my %params = ( ... );
\&     ...
\&     return $self\->generate_content(
\&                     \e%params, { message_key => \*(Aqmytask.template\*(Aq } );
\& }
.Ve
.PP
And an example of the second, passing the message key in the action
configuration (\f(CW\*(C`action.ini\*(C'\fR):
.PP
.Vb 2
\& [foo template_source]
\& mytask = msg:mytask.template
.Ve
.PP
In your message files you'd have:
.PP
.Vb 2
\& messages_en.msg:
\& mytask.template = mypackage::mytemplatename_english
\&
\& messages_es.msg:
\& mytask.template = mypackage::mytemplatename_spanish
.Ve
.PP
The templates get the exact same data under the exact same variable
names, but you can control the layout and text per language.
.PP
See
OpenInteract2::Manual::Templates
and OpenInteract2::Action for more
information.
.SS "Signficance of Message Filenames"
.IX Subsection "Signficance of Message Filenames"
The names of the filenames we process are fairly flexible, but one
aspect is not. The language \fBmust\fR be the last distinct set of
characters before the file extension. So the following are ok:
.PP
.Vb 3
\&  myapp\-en.msg         # lang is \*(Aqen\*(Aq
\&  myotherapp\-es\-MX.mo  #      ...\*(Aqes\-MX\*(Aq
\&  messages_en_HK.po    #      ...\*(Aqen_HK\*(Aq
.Ve
.PP
The following are not:
.PP
.Vb 3
\& english\-messages.msg
\& messages\-en\-part2.mo
\& messagesen.po
.Ve
.PP
If you create a message filename that does not conform to this
specification, it not only won't be processed but will halt the entire
localization reading process altogether.
.PP
You can check whether your application's message filenames are
formatted properly with the 'check_package' task will alert you to
malformed message filenames \*(-- see
OpenInteract2::Manage::Package::Check or just run from your package
development directory:
.PP
.Vb 1
\& $ oi2_manage check_package
.Ve
.SH "MESSAGE FILES"
.IX Header "MESSAGE FILES"
.SS "Supported Formats: \s-1PO\s0, \s-1MO\s0 and Custom"
.IX Subsection "Supported Formats: PO, MO and Custom"
OpenInteract2 supports reading localized messages from
\&\f(CW\*(C`gettext\*(C'\fR\-formatted files (a.k.a, '\s-1PO\s0' or '\s-1MO\s0' files) as well as a
custom format. All are treated in the same way \*(-- once read in all
messages get flattened into a single per-language namespace regardless
of their source.
.PP
To include localization files with your package just drop them into
the 'msg/' subdirectory. \s-1OI2\s0 will find them at server startup and read
them all in.
.PP
Note that if you use \s-1PO\s0 or \s-1MO\s0 files you'll need to have
Locale::Maketext::Lexicon installed. If you don't the server
startup process will halt and tell you to install it.
.SS "Custom Message File Format"
.IX Subsection "Custom Message File Format"
The message file format is fairly simple:
.IP "\fBskip comments and blanks\fR" 4
.IX Item "skip comments and blanks"
Unless we're in the middle of a continued value, we'll skip all
commented lines (those beginning with a '#') and blank lines.
.IP "\fBkey/value pairs\fR" 4
.IX Item "key/value pairs"
A message key is unique per language and has a single value that is
its associated message for that language. It is separated from the
message by an '='.
.IP "\fBcontinued values\fR" 4
.IX Item "continued values"
A message value may span multiple lines using the standard '\e'
notation at the end of a line. (Examples below.)
.IP "\fBruntime replacements\fR" 4
.IX Item "runtime replacements"
A message value may have one or more runtime replacements which match
up with parameters passed in. These replacement declarations can get
relatively sophisticated \*(-- we discuss them briefly below but for true
enlightenment read the documentation for
Locale::Maketext.
.PP
So here is a simple declaration for two message keys without
continued values or runtime replacements:
.PP
.Vb 2
\& company.title=Welcome to MyCompany!
\& company.phone   =   Call 412\-555\-1212 for more information.
.Ve
.PP
Two things to note:
.IP "1." 4
The keys ('company.title' and 'company.phone') are abstract and
semi-hierarchical. There's a \s-1FAQ\s0 below about why we chose opaque
message IDs for the core \s-1OI\s0 packages, but you don't have to do so. The
only tricky part is ensuring you don't stomp on someone else's
namespace. One way to do avoid this is using your package/application
name as the first part of the hierarchy.
.IP "2." 4
The message reader will truncate any whitespace around the '='.
.SS "Continued Message Values"
.IX Subsection "Continued Message Values"
Here's a declaration of two keys, one of which has a continued value:
.PP
.Vb 4
\& company.intro = You have decided to learn about MyCompany, a leader \e
\&     in the maintenance of the status quo around the world. Ensure your \e
\&     status is the one that\*(Aqs in quo!
\& company.title = Welcome to MyCompany!
.Ve
.PP
The main things here are:
.IP "1." 4
The '\e' \fBmust\fR be at the end of the line or the remainder of your
message will get lost. (You may have whitespace between the '\e' and
the end of line.)
.IP "2." 4
You can have multiple continuations for a single value. Leading space
from successive lines will be lopped off.
.IP "3." 4
The value returned will not have any embedded newlines. (\s-1TODO:\s0 This
may change, speak up if you have strong feelings about it.)
.SS "Runtime replacements"
.IX Subsection "Runtime replacements"
Since we just use Locale::Maketext behind the
scenes you can do anything in your message values that it allows. Here
is a quick summary of the most common options.
.PP
First, you often need to embed one or more values in a
message. Position is important: the translation of your message may
shift around the order of the values so you cannot treat it like a
\&\f(CW\*(C`sprintf\*(C'\fR. For instance, you might have:
.PP
.Vb 2
\& db.error.process = While processing the statement [_1] the database \e
\&     returned an error [_2]
.Ve
.PP
In another language this might be something like the following
nonsense:
.PP
.Vb 2
\& db.error.process = La base de datos volvio un error [_2] mientras \e
\&     que procesaba la declaracion [_1]
.Ve
.PP
When we ask for the message we need to pass in two values which will
get plugged into the message at runtime:
.PP
.Vb 9
\& my ( $sth );
\& eval {
\&     $sth = $dbh\->prepare( $sql );
\&     $sth\->execute();
\& };
\& if ( $@ ) {
\&   my $error_msg = $lh\->maketext( \*(Aqdb.error.process\*(Aq, $sql, $@ );
\&   # ...
\& }
.Ve
.PP
Since they're ordered there's no ambiguity.
.PP
Second, you often need to plugin values that depending on their value
may change words around them. For instance:
.PP
.Vb 1
\& cart.numitems = You have [_1] items in your shopping cart.
.Ve
.PP
Easy enough, but what happens when the number is 1? Or 0?
.PP
.Vb 2
\& You have 1 items in your shopping cart.
\& You have 0 items in your shopping cart.
.Ve
.PP
It's understandable, but not user-friendly. Fortunately
Locale::Maketext does this for us:
.PP
.Vb 1
\& cart.numitems = You have [quant,_1,item,items,no items]
.Ve
.PP
With a '1' this will generate:
.PP
.Vb 1
\& You have 1 item in your shopping cart.
.Ve
.PP
And with a '0':
.PP
.Vb 1
\& You have no items in your shopping cart.
.Ve
.PP
Nifty!
.SH "USAGE"
.IX Header "USAGE"
.SS "In Template Toolkit templates"
.IX Subsection "In Template Toolkit templates"
Since the Template Toolkit is the preferred content generation system
for \s-1OI\s0 it has the best support for fetching and displaying
messages. Every template has the function '\s-1MSG\s0' in its namespace. This
function takes a message key as the first argument and optional
parameters as successive arguments. Each of these gets filled in the
message in order. So you might have:
.PP
.Vb 1
\& [% MSG( \*(Aqsearch.results.count\*(Aq, results.size ) %]
.Ve
.PP
Which refers to a message key:
.PP
.Vb 1
\& search.results.count = You found [_1] types of candy
.Ve
.PP
The argument \f(CW\*(C`results.size\*(C'\fR will replace the \f(CW\*(C`[_1]\*(C'\fR placeholder when
the message is interpreted.
.PP
Additionally, many of the \s-1OI\s0 template widgets take message keys as
arguments in place of labels. For instance, instead of:
.PP
.Vb 1
\& [% INCLUDE header_row( labels = [ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq ] ) %]
.Ve
.PP
You can use:
.PP
.Vb 1
\& [% INCLUDE header_row( label_keys = [ \*(Aqlabel.foo\*(Aq, \*(Aqlabel.bar\*(Aq, \*(Aqlabel.baz\*(Aq ] ) %]
.Ve
.PP
Most of the time if the original argument was 'foo' the keyed argument
will be 'foo_key', so:
.PP
.Vb 5
\& Old (and still works):
\& [% INCLUDE label_form_text_row( label = \*(AqPhone Number\*(Aq,
\&                                 name  = \*(Aqphone_number\*(Aq,
\&                                 size  = 20 ) %]
\& [% INCLUDE form_button( value = \*(AqClick Me!\*(Aq ) %]
\& 
\& New:
\& [% INCLUDE label_form_text_row( label_key = \*(Aqmyform.phone\*(Aq,
\&                                 name      = \*(Aqphone_number\*(Aq,
\&                                 size      = 20 ) %]
\& [% INCLUDE form_button( value_key => \*(Aqglobal.button.click\*(Aq ) %]
.Ve
.SS "In code during a request"
.IX Subsection "In code during a request"
You can always grab a language handle from the
OpenInteract2::Request object:
.PP
.Vb 1
\& my $lh = CTX\->request\->language_handle;
.Ve
.PP
When first called during the request's lifetime this will determine
what language the user is using and get a suitable Locale::Maketext
handle. Successive calls during the request will return the same
handle.
.PP
You can then call 'maketext' on the object and get a translation:
.PP
.Vb 9
\& my $lh = CTX\->request\->language_handle;
\& my ( $sth );
\& eval {
\&     $sth = $dbh\->prepare( $sql );
\&     $sth\->execute();
\& };
\& if ( $@ ) {
\&   my $error_msg = $lh\->maketext( \*(Aqdb.error.process\*(Aq, $sql, $@ );
\&   ...
.Ve
.PP
OpenInteract2::Action subclasses have a shortcut with the \f(CW\*(C`_msg\*(C'\fR
method. (The underscore is an indication that it's reserved for
subclasses, a.k.a. 'protected' in other languages. The method itself
does not enforce this.) So if the above were in an action it might
look like this:
.PP
.Vb 11
\& sub do_something {
\&     my ( $self ) = @_;
\&     my ( $sth );
\&     eval {
\&         $sth = $dbh\->prepare( $sql );
\&         $sth\->execute();
\&     };
\&     if ( $@ ) {
\&         $self\->param_add(
\&             error_msg => $self\->_msg( \*(Aqdb.error.process\*(Aq, $sql, $@ ) );
\&     ...
.Ve
.SS "In code outside a request"
.IX Subsection "In code outside a request"
Assuming that you started up the OpenInteract2::Context object in
the normal fashion, you can just use the Locale::Maketext usage:
.PP
.Vb 2
\& my $lh = OpenInteract2::I18N\->get_handle( \*(Aqlang\*(Aq, \*(Aqlang\*(Aq, \*(Aqlang\*(Aq... );
\& die $lh\->maketext( \*(Aqdb.error.process\*(Aq, $sql, $@ );
.Ve
.PP
where each 'lang' is a user (or system) language in order of
preference.
.SH "FAQ"
.IX Header "FAQ"
\&\fBWhy did you use opaque IDs for the message keys?\fR
.PP
In the Locale::Maketext docs Sean Burke recommends
using keys based on the base language \*(-- that is, \fBnot\fR using opaque
message keys. His suggestion makes for very readable translation
documents but I think in practice it would be extremely brittle \*(-- if
you change the key in the base language even for punctuation you'll
need to change all of them. Feh. (Then again, Mr. Burke is a bona-fide
superhero, so we'll see how that shakes out...)
.PP
Additionally a lot of this was inspired by the message (or 'resource')
bundle technology built in to the Java 2 platform. (See \*(L"\s-1SEE\s0 \s-1ALSO\s0\*(R"
for more on this.) Message bundles shipped with applications built on
Struts or Spring typically use the hierarchical message syntax, with
different levels separated by a dot. So you might have
\&'myapp.search.label.firstname' which gets more specific as you
traverse the key from left to right. How specific you want to get is
up to you.
.PP
That said, there's nothing stopping you from using your own standard
for declaring keys in your application. Use \s-1ID\s0 numbers, letters, days
of the week, whatever. Just make sure your package's keys don't trod
on another's.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
OpenInteract2::I18N
.PP
OpenInteract2::I18N::Initializer
.PP
Locale::Maketext
.PP
Locale::Maketext::Lexicon
.PP
gettext: <http://www.gnu.org/software/gettext/>
.PP
openinteract-dev mailing list:
.PP
<http://lists.sourceforge.net/lists/listinfo/openinteract\-dev>
.PP
Article published in \s-1TPJ\s0 13 by Sean Burke about Locale::Maketext:
.PP
<http://search.cpan.org/~sburke/Locale\-Maketext\-1.06/lib/Locale/Maketext/TPJ13.pod>
.PP
Web Localization in Perl by Autrijus Tang
.PP
<http://www.autrijus.org/webl10n/TABLE_OF_CONTENTS.html>
.PP
Java Internationalization: Localization with ResourceBundles
.PP
<http://developer.java.sun.com/developer/technicalArticles/Intl/ResourceBundles/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2004 Chris Winters. All rights reserved.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
