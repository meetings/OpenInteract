.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::ContentGenerator::TT2Process 3"
.TH OpenInteract2::ContentGenerator::TT2Process 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::ContentGenerator::TT2Process \- Process Template Toolkit templates in OpenInteract
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # NOTE: You will probably never deal with this class. It\*(Aqs don\*(Aqe
\& # behind the scenes for you in the \*(Aq$action\->generate_content\*(Aq method
\& 
\& # Get a content generator by name from the context; name is
\& # configured in server configuration under \*(Aqcontent_generator\*(Aq
\& 
\& my $generator = CTX\->content_generator( \*(AqTT\*(Aq );
\& 
\& # Specify an object by fully\-qualified name (preferrred)
\& 
\& my $html = $generator\->generate( {}, { key => \*(Aqvalue\*(Aq },
\&                                  { name => \*(Aqmy_pkg::this_template\*(Aq } );
\& 
\& # Directly pass text to be parsed (fairly rare)
\& 
\& my $little_template = \*(AqText to replace \-\- here is my login name: \*(Aq .
\&                       \*(Aq[% login.login_name %]\*(Aq;
\& my $html = $generator\->generate( {}, { key => \*(Aqvalue\*(Aq },
\&                                  { text => $little_template } );
\& 
\& # Pass the already\-created object for parsing (rare)
\& 
\& my $site_template_obj = CTX\->lookup_class( \*(Aqtemplate\*(Aq )\->fetch( \*(Aqbase_main\*(Aq );
\& my $html = $generator\->generate( {}, { key => \*(Aqvalue\*(Aq },
\&                                  { object => $site_template_obj } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class processes templates within OpenInteract. The main method is
\&\f(CW\*(C`process()\*(C'\fR \*(-- just feed it a template name and a whole bunch of keys
and it will take care of finding the template (from a database,
filesystem, or wherever) and generating the finished content for you.
.PP
Shorthand used below: \s-1TT\s0 == Template Toolkit.
.SH "INITIALIZATION"
.IX Header "INITIALIZATION"
.SS "Base Initialization"
.IX Subsection "Base Initialization"
\&\fBinitialize( \e%config )\fR
.PP
Performs all initialization, including reading plugins from all
packages. It then creates a \s-1TT\s0 processing object with necessary
parameters and stores it for later use. We call \f(CW\*(C`initialize()\*(C'\fR from
OpenInteract2::ContentGenerator
when the \s-1OI2\s0 context is first initialized and never again so we can
perform expensive operations here.
.SS "Initializing Template Plugins"
.IX Subsection "Initializing Template Plugins"
To declare a plugin exported by a package, specify it in the
\&\f(CW\*(C`package.conf\*(C'\fR file for that package. The value is in two parts: the
first part is the name by which the plugin is known, the second is the
plugin class:
.PP
.Vb 1
\& template_plugin   MyPlugin   OpenInteract2::TT2Plugin::MyPlugin
.Ve
.PP
See
OpenInteract2::Manual::Templates
for information about creating your own template plugins.
.SS "Custom Initialization"
.IX Subsection "Custom Initialization"
You can define information in the server configuration of your website
that enables you to modify the configuration passed to the \f(CW\*(C`new()\*(C'\fR
method of Template.
.PP
In your server configuration, define
\&\f(CW\*(C`template_info.custom_init_class\*(C'\fR as the class that contains a method
\&'\fIcustom_template_initialize()\fR'. The method gets passed the template
configuration hashref, which you can modify in-place as you see
fit. It also gets a copy of the server configuration for the \s-1TT\s0
content generator as the second argument.
.PP
There are many variables that you can change; learn about them at
Template::Manual::Config. For example,
assume that \s-1TT\s0 can use the configuration variable '\s-1SUNSET\s0' to do
something. To set the variable:
.PP
.Vb 1
\& # In conf/server.ini
\& 
\& [content_generator TT]
\& ...
\& custom_init_class  = MyCustom::Template
\& 
\& # In MyCustom/Template.pm:
\& 
\& package MyCustom::Template;
\& 
\& use strict;
\& 
\& sub custom_template_initialize {
\&     my ( $class, $tt_config, $init_params ) = @_;
\&     $template_config\->{SUNSET} = \*(Aq7:13 AM\*(Aq;
\& }
.Ve
.PP
Easy! Since this is a normal Perl method, you can perform any actions
you like here. For instance, you can retrieve templates from a website
via \s-1LWP\s0, save them to your package template directory and process them
via \s-1PROCESS/INCLUDE\s0 as you normally would. Or set template
caching/compiling options on a \s-1SOAP\s0 server for your 100\-machine
cluster and read them from a single source.
.PP
Note that \f(CW\*(C`initialize()\*(C'\fR should only get executed once at context
initialization. (Standalone server: once; preforking server, probably
once per child.) Most of the time this is fairly infrequent, so you
can execute code here that takes a little more time than if it were
being executed with every request.
.SH "PROCESSING"
.IX Header "PROCESSING"
.SS "Base Processing"
.IX Subsection "Base Processing"
\&\fBgenerate( \e%template_params, \e%template_variables, \e%template_source )\fR
.PP
Generate template content, given keys and values in
\&\f(CW\*(C`\e%template_variables\*(C'\fR and a template identifier in
\&\f(CW\*(C`\e%template_source\*(C'\fR.
.PP
Parameters:
.IP "\(bu" 4
\&\fBtemplate_params\fR (\e%)
.Sp
Configuration options for the template. Note that you can set defaults
for these at configuration time as well.
.IP "\(bu" 4
\&\fBtemplate_variables\fR (\e%)
.Sp
The key/value pairs that will get plugged into the template. These can
be arbitrarily complex, since the Template Toolkit can do anything :\-)
.IP "\(bu" 4
\&\fBtemplate_source\fR
.Sp
Tell the method how to find the source for the template you want to
process. There are a number of ways to do this:
.Sp
Method 1: Use a combined name (preferred method)
.Sp
.Vb 1
\& name    => \*(Aqpackage_name::template_name\*(Aq
.Ve
.Sp
Method 2: Specify the text yourself
.Sp
.Vb 3
\& text    => $scalar_with_text
\& or
\& text    => \e$scalar_ref_with_text
.Ve
.Sp
Method 3: Specify an object of type
OpenInteract2::SiteTemplate
.Sp
.Vb 1
\& object => $site_template_obj
.Ve
.SS "Customized Variables"
.IX Subsection "Customized Variables"
You have the opportunity to step in during the executing of
\&\f(CW\*(C`generate()\*(C'\fR with every request and create/modify/remove template
variables. To do so, you need to define a handler and tell \s-1OI\s0 where it
is.
.PP
To define the handler, just define a normal Perl class method
\&'\fIcustomize_template_vars()\fR' that gets two arguments: the name of the
current template (in 'package::name' format) and the template variable
hashref:
.PP
.Vb 4
\& sub customize_template_vars {
\&     my ( $class, $template_name, $template_vars ) = @_;
\&     $template_vars\->{MOTD} = \*(AqNo matter where you go, there you are\*(Aq;
\& }
.Ve
.PP
To tell \s-1OI\s0 where your handler is, in your server configuration file
specify:
.PP
.Vb 3
\& [content_generator TT]
\& ...
\& custom_variable_class  = MyCustom::Template
.Ve
.PP
You can set (or, conceivably, remove) information bound for every
template. Variables set via this method are available to the template
just as if they had been passed in via the \f(CW\*(C`generate()\*(C'\fR call.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template
.PP
OpenInteract2::ContentGenerator
.PP
OpenInteract2::TT2::Context
.PP
OpenInteract2::TT2::Plugin
.PP
OpenInteract2::TT2::Provider
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
