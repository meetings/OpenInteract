.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::SQLInstall 3"
.TH OpenInteract2::SQLInstall 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::SQLInstall \-\- Dispatcher for installing various SQL data from packages to database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # PACKAGE AUTHORS
\& # Define a SQLInstaller for your package
\& 
\& package OpenInteract2::SQLInstall::MyPackage;
\& 
\& use strict;
\& use base qw( OpenInteract2::SQLInstall );
\& 
\& # We only define one object in this package
\& sub get_structure_set {
\&     return \*(Aqmyobj\*(Aq;
\& }
\& 
\& # Since we only have one set we can ignore it
\& sub get_structure_file {
\&     my ( $self, $set, $type ) = @_;
\&     return \*(Aqmyobj_sybase.sql\*(Aq                           if ( $type eq \*(AqSybase\*(Aq );
\&     return [ \*(Aqmyobj_oracle.sql\*(Aq, \*(Aqmyobj_sequence.sql\*(Aq ] if ( $type eq \*(AqOracle\*(Aq );
\&     return \*(Aqmyobj.sql\*(Aq;
\& }
\& 
\& # INSTALLER USERS
\& 
\& # See the management tasks for doing this for you, but you can also
\& # use this class in a separate program
\& 
\& use OpenInteract2::Context qw( CTX );
\& use OpenInteract2::SQLInstall;
\& 
\& my $package = CTX\->repository\->fetch_package( \*(Aqmypackage\*(Aq );;
\& my $installer = OpenInteract2::SQLInstall\->new_from_package( $package );
\& 
\& # Do one at a time
\& $installer\->install_structure;
\& 
\& # ..and restrict to processing a single file
\& $installer\->install_structure( \*(Aqtable\-A.sql\*(Aq );
\& 
\& $installer\->install_data;
\& $installer\->install_security;
\& 
\& # ... or all at once
\& $installer\->install_all;
\&_
\& # ... or migrate from an old package
\& $installer\->install_structure;
\& $installer\->migrate_data( \*(Aqold_datasource_name\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One of the difficulties with developing an application that can
potentially work with so many different databases is that it needs to
work with so many different databases. Many of the differences among
databases are dealt with by the amazing \s-1DBI\s0 module, but enough
remain to warrant some thought.
.PP
This module serves two audiences:
.IP "1." 4
The user of OpenInteract who wants to get packages, run a few commands
and have them simply work.
.IP "2." 4
The developer of OpenInteract packages who wants to develop for as
many databases as possible without too much of a hassle.
.PP
This module provides tools for both. The first group (users) does not
need to concern itself with how this module works \*(-- running the
various \f(CW\*(C`oi2_manage\*(C'\fR commands should be sufficient.
.PP
However, OpenInteract developers need a keen understanding of how
things work. This whole endeavor is a work-in-progress \*(-- things work,
but there will certainly be new challenges brought on by the wide
variety of applications for which OpenInteract can be used.
.SH "USERS: HOW TO MAKE IT HAPPEN"
.IX Header "USERS: HOW TO MAKE IT HAPPEN"
.SS "Typical Use"
.IX Subsection "Typical Use"
Every package has a module that has a handful of procedures specified
in such a way that OpenInteract knows what to call and for which
database. Generally, all you need to deal with is the wrapper provided
by the \f(CW\*(C`oi2_manage\*(C'\fR program. For instance:
.PP
.Vb 1
\& oi2_manage install_sql \-\-website_dir=/home/httpd/myOI \-\-package=mypackage
.Ve
.PP
This will install all of the structures, data and security objects
necessary for the package 'mypackage' to function. You can also
install the pieces individually:
.PP
.Vb 3
\& oi2_manage install_sql_structure \-\-website_dir=/home/httpd/myOI \-\-package=mypackage
\& oi2_manage install_sql_data \-\-website_dir=/home/httpd/myOI \-\-package=mypackage
\& oi2_manage install_sql_security \-\-website_dir=/home/httpd/myOI \-\-package=mypackage
.Ve
.PP
As long as you have specified your databsources properly in your
\&\f(CW\*(C`conf/server.ini\*(C'\fR file and enabled any custom associations between
the datasources and \s-1SPOPS\s0 objects, everything should flow smooth as
silk.
.SS "Migrating Data"
.IX Subsection "Migrating Data"
If you are migrating data from a version of this package installed in
OpenInteract 1.x, you will generally want:
.PP
.Vb 2
\& oi2_manage install_sql_structure \-\-website_dir=/home/httpd/myOI \-\-package=mypackage
\& oi2_manage migrate_data \-\-website_dir=/home/httpd/myOI \-\-package=mypackage
.Ve
.PP
Note that this will generally \fBnot\fR migrate the security data for the
handlers/objects. To do this run:
.PP
.Vb 1
\& oi2_manage migrate_data \-\-website_dir=/home/httpd/myOI \-\-package=base_security
.Ve
.SH "DEVELOPERS: CODING"
.IX Header "DEVELOPERS: CODING"
The \s-1SQL\s0 installation program of OpenInteract is a kind of mini
framework \*(-- you have the freedom to do anything you like in the
handlers for your package. But OpenInteract provides a number of tools
for you as well.
.SS "Subclassing: Methods to override"
.IX Subsection "Subclassing: Methods to override"
First, the basics. Here is the scoop on what you can override:
.PP
\&\fBinit( \e%params )\fR
.PP
Called from \f(CW\*(C`new()\*(C'\fR just before returning the object. All items in
\&\f(CW\*(C`\e%params\*(C'\fR that are object fields have already been set in the
object, the other entries remain untouched.
.PP
If there is a problem you should \f(CW\*(C`die\*(C'\fR with a useful error message.
.PP
Returns: nothing.
.PP
\&\fBinstall_structure( [ \f(CB@restrict_to_files\fB ] )\fR
.PP
If you have needs that declaration cannot fill, you can install the
structures yourself. You have access to the full
OpenInteract2::Context object so you can get
datasources, lookup \s-1SPOPS\s0 object information, etc. (See more in
section on customization below.)
.PP
If you do implement it note that, if they specify it, users will
expect that you only process files in \f(CW@restrict_to_files\fR.
.PP
\&\fB\f(BIget_structure_set()\fB\fR
.PP
Returns a set of keys used for matching up structure files with
datasources. (A structure file normally delineates a single table but
can also describe other objects, like sequences, generators or even
indices.) The return value is either a simple scalar or an
arrayref. Each member must be:
.IP "\fB'system'\fR" 4
.IX Item "'system'"
For structures to be installed to the \s-1OI\s0 system database.
.IP "\fB'datasource: \s-1NAME\s0'\fR" 4
.IX Item "'datasource: NAME'"
For structures to be installed to a particular datasource '\s-1NAME\s0'. This
is useful for tables that can be configured for a particular
datasource but are not an \s-1SPOPS\s0 object. The method should lookup the
proper datasource from the server configuration or some other
resource.
.IP "\fBspops-key\fR" 4
.IX Item "spops-key"
For structures to be installed in the datasource used by \f(CW\*(C`spops\-key\*(C'\fR.
.PP
So if you have two objects defined in your package you might have
something like:
.PP
.Vb 3
\& sub get_structure_set {
\&     return [ \*(AqobjectA\*(Aq, \*(AqobjectB\*(Aq ];
\& }
.Ve
.PP
Where 'objectA' and 'objectB' are \s-1SPOPS\s0 keys.
.PP
And in \f(CW\*(C`get_structure_file()\*(C'\fR you may have:
.PP
.Vb 10
\& sub get_structure_file {
\&     my ( $self, $set, $driver ) = @_;
\&     if ( $set eq \*(AqobjectA\*(Aq ) {
\&         return [ \*(AqobjectA.sql\*(Aq, \*(AqobjectALookup.sql\*(Aq ];
\&     }
\&     elsif ( $set eq \*(AqobjectB\*(Aq ) {
\&         if ( $driver eq \*(AqOracle\*(Aq ) {
\&             return [ \*(AqobjectB\-oracle\*(Aq, \*(AqobjectB\-sequence\*(Aq ];
\&         }
\&         return \*(AqobjectB.sql\*(Aq;
\&     }
\&     else {
\&         oi_error "Set \*(Aq$set\*(Aq not defined by this package.";
\&     }
\& }
.Ve
.PP
Note that you could also force the user to install all objects to the
same database, which makes sense for tables that use JOINs or whatnot:
.PP
.Vb 3
\& sub get_structure_set {
\&     return \*(AqobjectA\*(Aq;
\& }
\& 
\& # Now we don\*(Aqt care what the value of $set is...
\& 
\& sub get_structure_file {
\&     my ( $self, $set, $driver ) = @_;
\&     my @base = ( \*(AqobjectA.sql\*(Aq, \*(AqobjectALookup.sql\*(Aq );
\&     if ( $driver eq \*(AqOracle\*(Aq ) {
\&         return [ @base, \*(AqobjectB\-oracle\*(Aq, \*(AqobjectB\-sequence\*(Aq ];
\&     }
\&     return [ @base, \*(AqobjectB.sql\*(Aq ];
\& }
.Ve
.PP
\&\fBget_structure_file( \f(CB$set_name\fB, \f(CB$driver_type\fB )\fR
.PP
Return an arrayref of filenames based on the given \f(CW$set_name\fR and
\&\f(CW$driver_type\fR. This should include any tables and supporting
objects, like sequences for PostgreSQL/Oracle or generators for
FirebirdSQL/InterBase. See examples above.
.PP
\&\fB\f(BIinstall_data()\fB\fR
.PP
If you have needs that declaration cannot fill, you can install data
yourself. You have access to the full
OpenInteract2::Context object so you can get
datasources, lookup \s-1SPOPS\s0 object information, etc. (See more in
section on customization below.)
.PP
\&\fB\f(BIget_data_file()\fB\fR
.PP
Returns an arrayref of filenames with data to import. See discussion
below on importing data for more information on what these files can
contain.
.PP
\&\fB\f(BIinstall_security()\fB\fR
.PP
If you have needs that declaration cannot fill, you can install
security objects yourself. You have access to the full
OpenInteract2::Context object so you can get
datasources, lookup \s-1SPOPS\s0 object information, etc. (See more in
section on customization below.)
.PP
\&\fB\f(BIget_security_file()\fB\fR
.PP
Returns an arrayref of filenames with security data to import.
.PP
\&\fBtransform_data( \f(CB$importer\fB )\fR
.PP
This is \fBoptional\fR and called by the process behind \f(CW\*(C`install_data()\*(C'\fR
and \f(CW\*(C`install_security()\*(C'\fR. By default \s-1OI\s0 will change fields marked
under 'transform_default' and 'transform_now' as discussed in the data
import documentation below. But if you have other install-time
transformations you would like to accomplish you can do them here.
.PP
The \f(CW$importer\fR is a SPOPS::Import object. You can
get the field order and modify the data in-place:
.PP
.Vb 6
\& my $install_time = time;
\& my $field_order = $importer\->fields_as_hashref;
\& foreach my $data ( @{ $importer\->data } ) {
\&     my $idx = $field_order\->{myfield};
\&     $data\->[ $idx ] = ( $install_time % 2 == 0 ) ? \*(Aqeven\*(Aq : \*(Aqodd\*(Aq;
\& }
.Ve
.PP
So here is an example of a subclass that puts a number of the above
items together:
.PP
.Vb 1
\& package OpenInteract2::MyPackage::SQLInstall;
\& 
\& use strict;
\& use base qw( OpenInteract2::SQLInstall );
\& use OpenInteract2::Context qw( CTX );
\& 
\& # Lookup in the server configuration the name of the field to
\& # transform. (This is not actually there, just an example.)
\& 
\& sub init {
\&     my ( $self ) = @_;
\&     $self\->{_my_transform_field} = CTX\->server_config\->{mypackage}{transform};
\& }
\& 
\& sub get_structure_set {
\&     return \*(AqobjectA\*(Aq;
\& }
\& 
\& # We don\*(Aqt care what the value of $set is since there is only one
\& # possible value
\& 
\& sub get_structure_file {
\&     my ( $self, $set, $driver ) = @_;
\&     my @base = ( \*(AqobjectA.sql\*(Aq, \*(AqobjectALookup.sql\*(Aq );
\&     if ( $driver eq \*(AqOracle\*(Aq ) {
\&         return [ @base, \*(AqobjectB\-oracle\*(Aq, \*(AqobjectB\-sequence\*(Aq ];
\&     }
\&     return [ @base, \*(AqobjectB.sql\*(Aq ];
\& }
\& 
\& sub transform_data {
\&     my ( $self, $importer ) = @_;
\&     my $install_time = time;
\&     my $field_order = $importer\->fields_as_hashref;
\&     my $idx = $field_order\->{ $self\->{_my_transform_field} };
\&     return unless ( $idx );
\&     foreach my $data ( @{ $importer\->data } ) {
\&         $data\->[ $idx ] = ( $install_time % 2 == 0 ) ? \*(Aqeven\*(Aq : \*(Aqodd\*(Aq;
\&     }
\&     # Remember to call the main method!
\&     $self\->SUPER::transform_data( $importer );
\& }
.Ve
.PP
\&\fBmigrate_data( \f(CB$old_datasource\fB )\fR
.PP
If you override this method you need to do part or all of the data
migration yourself. You can also use a more declarative style and
override \f(CW\*(C`get_migration_information()\*(C'\fR, specifying the keys and
tables to use for the migration. This is recommended.
.PP
Note that \f(CW$old_datasource\fR is just a \s-1DBI\s0 database handle which you
can create and connect in any manner you choose. It is normally
specified by the user and created by the framework for you.
.PP
\&\fB\f(BIget_migration_information()\fB\fR
.PP
Returns an arrayref of hashrefs describing how to migrate data for
this package. See \*(L"\s-1DEVELOPERS:\s0 \s-1MIGRATING\s0 \s-1DATA\s0\*(R" for more information
.SH "DEVELOPERS: MIGRATING DATA"
.IX Header "DEVELOPERS: MIGRATING DATA"
Since OpenInteract2 is a fairly major upgrade you may want to take the
opportunity to rethink how you're organizing your data, a difficult
task to do when you're trying to maintain the status quo. Several of
the packages in \s-1OI2\s0 took advantage of this so we needed to create a
framework to make moving data easy. Thus this section.
.PP
This class supports two types of migration: moving data from a table
to another table (known as 'data\-to\-data') or moving data from a table
to a set of \s-1SPOPS\s0 objects which save themselves
('data\-to\-object'). The latter is preferred because it takes advantage
of pre-existing \s-1SPOPS\s0 hooks for data transformation and collection
such as full-text indexing.
.SS "Moving data from table to objects"
.IX Subsection "Moving data from table to objects"
For a \fBdata-to-object\fR migration you can specify a number of
fields. Full examples follow.
.IP "\(bu" 4
\&\fBspops_class\fR ($)
.Sp
The class of the \s-1SPOPS\s0 object you're migrating data to.
.IP "\(bu" 4
\&\fBtable\fR ($)
.Sp
The name of the table you're migrating data from. You don't need to
specify the destination table since the metadata in the \s-1SPOPS\s0 class
will take care of that.
.Sp
You can leave this undefined if the name of the table is the same in
the source and destination \*(-- we'll just use the value pulled from
\&\f(CW\*(C`spops_class\*(C'\fR for both.
.IP "\(bu" 4
\&\fBfield\fR (\e@ or \e%)
.Sp
You can either use an arrayref to name the fields, in which case
you're using the names from the old datasource as the fieldnames in
your \s-1SPOPS\s0 object. Or you can use a hashref, naming the fields in the
old table in an arrayref using the key 'old', fields in the \s-1SPOPS\s0
object using 'new', where the first field in 'old' maps to the first
field in 'new', etc.
.Sp
If you assign undef, an empty arrayref or an empty hashref to this key
we'll get the fieldnames from the \f(CW\*(C`spops_class\*(C'\fR method 'field_list'
and use them for both the source and destination.
.IP "\(bu" 4
\&\fBinclude_id\fR ('yes' (default) or 'no')
.Sp
When moving data you'll almost certainly wish to preserve the IDs of
the objects you're moving. This is the default, which overrides the
\&\s-1SPOPS\s0 default of generating IDs for you, even if you specify a value
for the \s-1ID\s0.
.IP "\(bu" 4
\&\fBtransform_sub\fR (\e& or \e@) (optional)
.Sp
Pass along any transformation subroutines in an arrayref of
coderefs. (A single routine can be passed by itself.) Each subroutine
should take three arguments: the migration information, a hashref of
the source database row, and the \s-1SPOPS\s0 object created from that
information. No return value is required: if you need to modify the
data to be saved change the \s-1SPOPS\s0 object.
.PP
Here is an example of the most common case: we're moving data between a
table and an \s-1SPOPS\s0 class with no transformation, the same table name
and the same field names:
.PP
.Vb 4
\& sub get_migration_info {
\&     my %user_info = ( spops_class => \*(AqOpenInteract2::User\*(Aq );
\&     return [ \e%user_info ];
\& }
.Ve
.PP
Here is an example where we're using the same table name between the
two databases but the fieldnames are changing:
.PP
.Vb 7
\& sub get_migration_info {
\&     my %user_info = (
\&       spops_class => \*(AqOpenInteract2::User\*(Aq,
\&       field       => { old => [ \*(Aquser_id\*(Aq, \*(Aqlogin_name\*(Aq, \*(Aqfirst_name\*(Aq, \*(Aqlast_name\*(Aq ],
\&                        new => [ \*(Aqsys_user_id\*(Aq, \*(Aqsys_login_name\*(Aq, \*(Aqsys_first_name\*(Aq, \*(Aqsys_last_name\*(Aq ] });
\&     return [ \e%user_info ];
\& }
.Ve
.PP
Here is an example where the table names change as well:
.PP
.Vb 10
\& sub get_migration_info {
\&     my %user_info = (
\&       spops_class => \*(AqOpenInteract2::User\*(Aq,
\&       table       => { old => \*(Aqsys_user\*(Aq,
\&                        new => \*(Aquser\*(Aq },
\&       field       => { old => [ \*(Aquser_id\*(Aq, \*(Aqlogin_name\*(Aq, \*(Aqfirst_name\*(Aq, \*(Aqlast_name\*(Aq ],
\&                        new => [ \*(Aqsys_user_id\*(Aq, \*(Aqsys_login_name\*(Aq, \*(Aqsys_first_name\*(Aq, \*(Aqsys_last_name\*(Aq ] }
\&     );
\&     return [ \e%user_info ];
\& }
.Ve
.PP
And here is an example of a transformation subroutine that smashes the
first and last name into a new field, wiki name:
.PP
.Vb 5
\& sub _create_wiki_name {
\&     my ( $migration_info, $db_row, $user ) = @_;
\&     $user\->wiki_name( ucfirst( lc( $user\->first_name ) ) .
\&                       ucfirst( lc( $user\->last_name ) ) );
\& }
.Ve
.PP
And you'd pass this to the process like this:
.PP
.Vb 7
\& sub get_migration_info {
\&     my %user_info = ( spops_class => \*(AqOpenInteract2::User\*(Aq,
\&                       table       => \*(Aqsys_user\*(Aq,
\&                       field       => [ \*(Aquser_id\*(Aq, \*(Aqlogin_name\*(Aq, \*(Aqfirst_name\*(Aq, \*(Aqlast_name\*(Aq ],
\&                       transform_sub => \e&_create_wiki_name, );
\&     return [ \e%user_info ];
\& }
.Ve
.SS "Moving data from table to table"
.IX Subsection "Moving data from table to table"
You should only need to use this when you're moving data between
tables that aren't represented by \s-1SPOPS\s0 objects.
.PP
Note that you cannot specify a destination datasource for this type of
migration. We just use the default \s-1DBI\s0 datasource.
.PP
For each \fBdata-to-data\fR migration here is what you need to specify:
.IP "\(bu" 4
\&\fBtable\fR ($ or \e%)
.Sp
You can either use a scalar to name the table, in which case it is the
same name in the old and new databases, or you can name the table the
old data are held in using the key 'old', new data using 'new'.
.IP "\(bu" 4
\&\fBfield\fR (\e@ or \e%)
.Sp
You can either use an arrayref to name the fields, in which case
they're the same names in the old and new databases, or you can name
the fields in the old table in an arrayref using the key 'old', new
fields using 'new', where the first field in 'old' maps to the first
field in 'new', etc.
.IP "\(bu" 4
\&\fBtransform_sub\fR (\e& or \e@) (optional)
.Sp
Pass along any transformation subroutines in an arrayref of
coderefs. (A single routine can be passed by itself.) Each subroutine
should take three arguments: the migration information, the arrayref
of data pulled from the database, and a hashref of new field to the
value of that field. The routine should not return anything, instead
modifying the hashref of new field data in place.
.PP
Here is an example of the most common case: we're moving data between
two tables with the same structure with no transformation:
.PP
.Vb 5
\& sub get_migration_info {
\&     my %sys_group_info = ( table => \*(Aqsys_group_user\*(Aq,
\&                            field => [ \*(Aqgroup_id\*(Aq, \*(Aquser_id\*(Aq ] );
\&     return [ \e%sys_group_info ];
\& }
.Ve
.PP
Here is an example where we're using the same table name between the
two databases but the fieldnames are changing:
.PP
.Vb 6
\& sub get_migration_info {
\&     my %sys_group_info = ( table => \*(Aqsys_group_user\*(Aq,
\&                            field => { old => [ \*(Aqgroup_id\*(Aq, \*(Aquser_id\*(Aq ],
\&                                       new => [ \*(Aqsys_group_id\*(Aq, \*(Aqsys_user_id\*(Aq ], } );
\&     return [ \e%sys_group_info ];
\& }
.Ve
.PP
Here is an example where the table names change as well:
.PP
.Vb 7
\& sub get_migration_info {
\&     my %sys_group_info = ( table => { old => \*(Aqsys_group_user\*(Aq,
\&                                       new => \*(Aqgroup_user_map\*(Aq, },
\&                            field => { old => [ \*(Aqgroup_id\*(Aq, \*(Aquser_id\*(Aq ],
\&                                       new => [ \*(Aqsys_group_id\*(Aq, \*(Aqsys_user_id\*(Aq ], } );
\&     return [ \e%sys_group_info ];
\& }
.Ve
.SH "DEVELOPERS: IMPORTING DATA"
.IX Header "DEVELOPERS: IMPORTING DATA"
We need to be able to pass data from one database to another and be
very flexible as to how we do it. The various data file formats have
taken care of everything I could think of \*(-- hopefully you will think
up some more.
.PP
The data file discussed below is a Perl data structure. This does
against the general \s-1OI2\s0 bias against using data structures for humans
to edit, but since this is generally a write-once operation it is not
as important that it be human-readable.
.PP
To begin, there are two elements to a data file. The first element
tells the installer what type of data follows \*(-- should we create
objects from them? Should we just plug the values into an \s-1SQL\s0
statement and execute it against a particular table?
.PP
The second element is the actual data, which is in an order determined
by the first element.
.PP
There are several different ways to process a data file. Both are
described in detail below:
.PP
\&\fBObject Processing\fR
.PP
Object processing allows you to just specify the field order and the
class, then let \s-1SPOPS\s0 do the dirty work. This is the preferred way of
transferring data, but it is not always feasible. An example where it
is not feasible include linking tables that \s-1SPOPS\s0 uses but does not
model.
.PP
\&\fB\s-1SQL\s0 Processing\fR
.PP
\&\s-1SQL\s0 processing allows you to present elements of a \s-1SQL\s0 statement and
plug in values as many times as necessary. This can be used most
anywhere and for anything. And you can use this for updating and
deleting data as well as inserting.
.SS "Object Processing"
.IX Subsection "Object Processing"
The first item in the list describes the class you want to use to
create objects and the order the fields that follow are in. Here is a
simple example of the data file used to install initial groups:
.PP
.Vb 7
\&  $data_group = [ { import_type => \*(Aqobject\*(Aq,
\&                    spops_class => \*(AqOpenInteract2::Group\*(Aq,
\&                    field_order => [ qw/ group_id name / ] },
\&                  [ 1, \*(Aqadmin\*(Aq ],
\&                  [ 2, \*(Aqpublic\*(Aq ],
\&                  [ 3, \*(Aqsite admin\*(Aq ],
\&  ];
.Ve
.PP
Here is a slightly abbreviated form of what steps would look like if
they were done in code:
.PP
.Vb 9
\& my $object_class = \*(AqOpenInteract2::Group\*(Aq;
\& my %field_num = { group_id => 0, name => 1 };
\& foreach my $row ( @{ $data_rows } ) {
\&   my $object = $object_class\->new();
\&   $object\->{group_id} = $row\->[ $field_num{group_id} ];
\&   $object\->{name}     = $row\->[ $field_num{name} ];
\&   $object\->save({ is_add => 1, skip_security => 1,
\&                   skip_log => 1, skip_cache => 1 });
\& }
.Ve
.PP
Easy!
.PP
You can also specify operations to perform on the data before they are
saved with the object. The most common operation of this is in
security data:
.PP
.Vb 10
\&  $security = [
\&                { import_type       => \*(Aqobject\*(Aq,
\&                  spops_class       => \*(AqOpenInteract2::Security\*(Aq,
\&                  field_order       => [ qw/ class object_id scope scope_id security_level / ],
\&                  transform_default => [ \*(Aqscope_id\*(Aq ] },
\&                [ \*(AqOpenInteract2::Group\*(Aq,         1, \*(Aqw\*(Aq, \*(Aqworld\*(Aq, 1 ],
\&                [ \*(AqOpenInteract2::Group\*(Aq,         2, \*(Aqw\*(Aq, \*(Aqworld\*(Aq, 4 ],
\&                [ \*(AqOpenInteract2::Group\*(Aq,         2, \*(Aqg\*(Aq, \*(Aqsite_admin_group\*(Aq, 8 ],
\&                [ \*(AqOpenInteract2::Group\*(Aq,         3, \*(Aqw\*(Aq, \*(Aqworld\*(Aq, 4 ],
\&                [ \*(AqOpenInteract2::Group\*(Aq,         3, \*(Aqg\*(Aq, \*(Aqsite_admin_group\*(Aq, 8 ],
\&                [ \*(AqOpenInteract2::Action::Group\*(Aq, 0, \*(Aqw\*(Aq, \*(Aqworld\*(Aq, 4 ],
\&                [ \*(AqOpenInteract2::Action::Group\*(Aq, 0, \*(Aqg\*(Aq, \*(Aqsite_admin_group\*(Aq, 8 ]
\&  ];
.Ve
.PP
So these steps would look like:
.PP
.Vb 10
\& my $object_class = \*(AqOpenInteract2::Security\*(Aq;
\& my %field_num = { class => 0, object_id => 1, scope => 2,
\&                   scope_id => 3, security_level => 4 };
\& my $defaults = CTX\->lookup_default_object_id;
\& foreach my $row ( @{ $data_rows } ) {
\&   my $object = $object_class\->new();
\&   $object\->{class}     = $row\->[ $field_num{class} ];
\&   $object\->{object_id} = $row\->[ $field_num{object_id} ];
\&   $object\->{scope}     = $row\->[ $field_num{scope} ];
\&   my $scope_id         = $row\->[ $field_num{scope_id} ];
\&   $object\->{scope_id}  = $defaults\->{ $scope_id } || $scope_id;
\&   $object\->{level}     = $row\->[ $field_num{security_level} ];
\&   $object\->save({ is_add   => 1, skip_security => 1,
\&                   skip_log => 1, skip_cache    => 1 });
\& }
.Ve
.PP
There are currently just a few behaviors you can set to transform the
data before it gets saved (see \f(CW\*(C`transform_data()\*(C'\fR above), but the
interface is there to do just about anything you can imagine.
.PP
If you are interested in learning more about this process see
SPOPS::Manual::ImportExport.
.SS "\s-1SQL\s0 Processing: Inserting Raw Data"
.IX Subsection "SQL Processing: Inserting Raw Data"
The actions performed when you just want to insert data into tables is
similar to those performed when you are inserting objects. The only
difference is that you need to specify a little more. Here is an
example:
.PP
.Vb 6
\&  $data_link = [ { import_type        => \*(Aqdbdata\*(Aq,
\&                   datasource_pointer => \*(Aqgroup\*(Aq,
\&                   sql_table          => \*(Aqsys_group_user\*(Aq,
\&                   field_order        => [ qw/ group_id user_id / ] },
\&                 [ 1, 1 ]
\&  ];
.Ve
.PP
So we specify the import type ('dbdata', which corresponds to
SPOPS::Import::DBI::Data), the table to operate on
('sys_group_user'), the order of fields in the data rows
('field_order', just like with processing objects) and then list the
data.
.PP
You must also tell \s-1OI2\s0 which datasource to use using the
\&'datasource_pointer' parameter. Typically you will want to use the
datasource associated with a particular \s-1SPOPS\s0 object, which you can do
by specifying the name of the \s-1SPOPS\s0 object:
.PP
.Vb 2
\& # uses the datasource associated with the SPOPS \*(Aqgroup\*(Aq object
\& datasource_pointer => \*(Aqgroup\*(Aq,
.Ve
.PP
You can also explicitly name the datasource:
.PP
.Vb 2
\& # name the actual datasource to use
\& datasource_pointer => \*(Aqdatasource: main_server\*(Aq,
.Ve
.PP
Finally, you can tell \s-1OI2\s0 to use whatever it is using as the 'system'
datasource, which is mapped in the 'datasource_config.system' server
configuration key:
.PP
.Vb 2
\& # use the \*(Aqsystem\*(Aq datasource
\& datasource_pointer => \*(Aqsystem\*(Aq,
.Ve
.PP
You are also able to specify the data types. Most of the time this
should not be necessary: if the database driver (e.g.,
DBD::mysql) supports it, the
SPOPS::SQLInterface file has routines to
discover data types in a table and do the right thing with regards to
quoting values.
.PP
However, if you do find it necessary you can use the following simple
type \-> \s-1DBI\s0 type mappings:
.PP
.Vb 5
\& \*(Aqint\*(Aq   \-> DBI::SQL_INTEGER(),
\& \*(Aqnum\*(Aq   \-> DBI::SQL_NUMERIC(),
\& \*(Aqfloat\*(Aq \-> DBI::SQL_FLOAT(),
\& \*(Aqchar\*(Aq  \-> DBI::SQL_VARCHAR(),
\& \*(Aqdate\*(Aq  \-> DBI::SQL_DATE(),
.Ve
.PP
Here is a sample usage:
.PP
.Vb 10
\&  $data_link = [ { import_type => \*(Aqdbdata\*(Aq,
\&                   sql_table   => \*(Aqsys_group_user\*(Aq,
\&                   field_order => [ qw/ group_id user_id link_date priority_level / ],
\&                   field_type  => { group_id       => \*(Aqint\*(Aq,
\&                                    user_id        => \*(Aqint\*(Aq,
\&                                    link_date      => \*(Aqdate\*(Aq,
\&                                    priority_level => \*(Aqchar\*(Aq },
\&                  },
\&                 [ 1, 1, \*(Aq2000\-02\-14\*(Aq, \*(Aqhigh\*(Aq ]
\&  ];
.Ve
.PP
Additionally you can create Perl code to do this for you.
.SS "\s-1SQL\s0 Processing: Updating Data"
.IX Subsection "SQL Processing: Updating Data"
In a \s-1SQL\s0 installation you can also update existing data. This can be
very useful if you are upgrading package versions and need to change
data formats, modify content, or whatever.
.PP
Declaring an update is fairly simple \*(-- unlike the 'dbdata' import
type you do not need to specify any data, just metadata:
.PP
.Vb 8
\&  $update = [ { import_type => \*(Aqdbupdate\*(Aq,
\&                datasource_pointer  => \*(Aqgroup\*(Aq,
\&                sql_table   => \*(Aqsys_group_user\*(Aq,
\&                where       => \*(Aqgroup_id > ?\*(Aq,
\&                value       => [ \*(Aq10\*(Aq ],
\&                field       => [ \*(Aqname\*(Aq ],
\&                field_value => [ \*(AqA New Group\*(Aq ],
\&              } ];
.Ve
.PP
(See \*(L"\s-1SQL\s0 Processing: Inserting Data\*(R" for how to declare a datasource
using 'datasource_pointer'.)
.PP
The fields you can use are specified in
SPOPS::Import::DBI::Update. Note that you can do this
programmatically as well:
.PP
.Vb 3
\& sub install_data {
\&     my ( $self ) = @_;
\&     my $action_name = \*(Aqupdate group name\*(Aq;
\&
\&     my $importer = SPOPS::Import\->new( \*(Aqdbupdate\*(Aq );
\&     my $ds_name = CTX\->spops_config\->{group}{datasource};
\&     $importer\->db( CTX\->datasource( $ds_name ) );
\&     $importer\->table( \*(Aqsys_group_user\*(Aq );
\&     $importer\->where( \*(Aqgroup_id > ?\*(Aq );
\&     $importer\->add_where_param( \*(Aq10\*(Aq );
\&     $importer\->set_update_data({ name => \*(AqA New Group\*(Aq });
\&     my $status = eval { $importer\->run() };
\&     if ( $@ ) {
\&         my $error = $@ || $status\->[0][2];
\&         $self\->_set_state( $action_name,
\&                            undef,
\&                            "Failed to update group names: $error",
\&                            undef );
\&     }
\&     else {
\&         $self\->_set_state( $action_name,
\&                            $status\->[0][1],
\&                            \*(AqUpdated group names ok\*(Aq,
\&                            undef );
\&     }
\&
\&     # If you have additional processing...
\&     return $self\->SUPER::install_data();
\& }
.Ve
.SS "\s-1SQL\s0 Processing: Deleting Data"
.IX Subsection "SQL Processing: Deleting Data"
In a \s-1SQL\s0 installation you can also delete existing data. This can be
very useful if you are upgrading package versions and need to remove
deprecated data or ensure an existing dataset is consistent.
.PP
Declaring a delete is fairly simple \*(-- unlike the 'dbdata' import
type you do not need to specify any data, just metadata:
.PP
.Vb 6
\&  $update = [ { import_type => \*(Aqdbdelete\*(Aq,
\&                datasource_pointer => \*(Aqgroup\*(Aq,
\&                sql_table   => \*(Aqsys_group_user\*(Aq,
\&                where       => \*(Aqgroup_id > ?\*(Aq,
\&                value       => [ \*(Aq10\*(Aq ]
\&              } ];
.Ve
.PP
(See \*(L"\s-1SQL\s0 Processing: Inserting Data\*(R" for how to declare a datasource
using 'datasource_pointer'.)
.PP
The fields you can use are specified in
SPOPS::Import::DBI::Delete. You can perform this action
programmatically as well \*(-- see the docs for updating data for an
example.
.SH "DEVELOPERS: CUSTOM BEHAVIOR"
.IX Header "DEVELOPERS: CUSTOM BEHAVIOR"
(Or: \*(L"The Declaration Is Not Enough\*(R")
.PP
As mentioned above, you can override any of the \f(CW\*(C`install_*\*(C'\fR methods
for the ultimate flexibility. For instance, in the \f(CW\*(C`base_user\*(C'\fR
package we create a 'superuser' object with a password generated at
runtime.
.PP
You can do anything you like in the \f(CW\*(C`install_structure\*(C'\fR,
\&\f(CW\*(C`install_data\*(C'\fR or \f(CW\*(C`install_security\*(C'\fR methods. You have the full
OpenInteract2::Context available to you,
including the configuration for the \s-1SPOPS\s0 objects, datasources, and
full server configuration.
.SS "Responsibilities"
.IX Subsection "Responsibilities"
When you implement custom behavior you have certain
responsibilities. The contract with programs using this object says
that every 'file' is associated with a status and, if it failed, an
error message. (It may also be associated with a statement and
datasource name.) Once the actions are completed the user can query
this object to see what was done along with the status of the actions
and any errors that were encountered.
.PP
The word \fBfile\fR is in quotes because it should really be something
more abstract like 'distinct action'. But because most of the time
actions are file-based and everyone understands files, that is the way
it is. But you are not constrained by this. So in the example above
where we create the superuser object I could give that action a name
of 'create administrator' and everyone would know what I meant.
.PP
For example, here is what such an implementation might look like:
.PP
.Vb 10
\& sub install_data {
\&     my ( $self ) = @_;
\&     my $action_name = \*(Aqcreate administrator\*(Aq;
\&     my $server_config = CTX\->server_config;
\&     my $email = $server_config\->{mail}{admin_email};
\&     my $id    = $server_config\->{default_objects}{superuser};
\&     my $user = CTX\->lookup_object( \*(Aquser\*(Aq )
\&                   \->new({ email      => $email,
\&                           login_name => \*(Aqsuperuser\*(Aq,
\&                           first_name => \*(AqSuper\*(Aq,
\&                           last_name  => \*(AqUser\*(Aq,
\&                           user_id    => $id });
\&     my $password = SPOPS::Utility\->generate_random_code(8);
\&     if ( $server_config\->{login}{crypt_password} ) {
\&         $user\->{password} = SPOPS::Utility\->crypt_it( $password );
\&     }
\&     eval { $user\->save({ is_add        => 1,
\&                          skip_security => 1,
\&                          skip_cache    => 1,
\&                          skip_log      => 1 }) };
\&     if ( $@ ) {
\&         $log\->error( "Failed to create superuser: $@" );
\&         $self\->_set_state( $action_name,
\&                            undef,
\&                            "Failed to create admin user: $@",
\&                            undef );
\&     }
\&     else {
\&         my $msg_ok = join( \*(Aq\*(Aq, \*(AqCreated administrator ok. \*(Aq,
\&                                \*(Aq**WRITE THIS PASSWORD DOWN!** \*(Aq,
\&                                "Password: $password" );
\&         $self\->_set_state( $action_name, 1, $msg_ok, undef );
\&     }
\&
\&     # If we needed to process any data files in addition to the
\&     # above, we could do:
\&     # $self\->SUPER::install_data();
\& }
.Ve
.SS "Custom Methods to Use"
.IX Subsection "Custom Methods to Use"
\&\fBprocess_data_file( \f(CB@files\fB )\fR
.PP
Implemented by this class to process and install data from the given
data files. If you're generating your own files it may prove useful.
.PP
\&\fB_set_status( \f(CB$file\fB, 0|1 )\fR
.PP
\&\fB_set_error( \f(CB$file\fB, \f(CB$error\fB )\fR
.PP
\&\fB_set_statement( \f(CB$file\fB, \f(CB$statement\fB )\fR
.PP
\&\fB_set_datasource( \f(CB$file\fB, \f(CB$datasource_name\fB )\fR
.PP
\&\fB_set_state( \f(CB$file\fB, 0|1, \f(CB$error\fB, \f(CB$statement\fB )\fR
.SH "TO DO"
.IX Header "TO DO"
\&\fBDumping data for transfer\fR
.PP
It would be nice if you could do something like:
.PP
.Vb 1
\& oi2_manage dump_sql \-\-website_dir=/home/httpd/myOI \-\-package=mypkg
.Ve
.PP
And get in your \f(CW\*(C`data/dump\*(C'\fR directory a series of files that can be
read in by another OpenInteract website for installation. This is
the pie in the sky \*(-- developing something like this would be really
cool.
.PP
And we can, but only for \s-1SPOPS\s0 objects. It is quite simple for us to
read data from a flat file, build objects from the data and save them
into a random database \*(-- \s-1SPOPS\s0 was built for this!
.PP
However, structures are a problem with this. Data that are not held in
objects are a problem. And dealing with dependencies is an even bigger
problem.
.PP
\&\fBSingle-action process\fR
.PP
Creating a script that allowed you to do:
.PP
.Vb 2
\& oi_sql_process \-\-database=Sybase \e
\&                \-\-apply=create_structure < table.sql > sybase_table.sql
.Ve
.PP
would be pretty nifty.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SPOPS::Manual::ImportExport
.PP
SPOPS::Import
.PP
OpenInteract2::Package
.PP
\&\s-1DBI\s0
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
