.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::ResultsManage 3"
.TH OpenInteract2::ResultsManage 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::ResultsManage \- Save and retrieve generic search results
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use OpenInteract2::ResultsManage;
\& 
\& # Basic usage
\& 
\& ... perform search ...
\& 
\& my $results = OpenInteract2::ResultsManage\->new();
\& $results\->save( \e@id_list );
\& $request\->session\->{this_search_id} = $results\->{search_id};
\& 
\& ... another request from this user ...
\& 
\& my $results = OpenInteract2::ResultsManage\->new({
\&     search_id => $request\->session\->{this_search_id}
\& });
\& my $result_list = $results\->retrieve();
\& 
\& # Use with paged results
\& 
\& my $results = OpenInteract2::ResultsManage\->new();
\& $results\->save( \e@id_list );
\& $request\->session\->{this_search_id} = $results\->{search_id};
\& my $page_num = $request\->param( \*(Aqpagenum\*(Aq );
\& my ( $min, $max ) = $results\->find_page_boundaries( $page_num, $HITS_PER_PAGE );
\& my ( $results, $total_count ) = $results\->retrieve({ min => $min, max => $max } );
\& my $total_pages = $results\->find_total_page_count( $HITS_PER_PAGE );
\& my $total_hits = $results\->{num_records};
\& 
\& # Can now print "Page $page_num of $total_pages" or you
\& # can pass this information to the template and use the
\& # \*(Aqpage_count\*(Aq component and pass it \*(Aqtotal_pages\*(Aq,
\& # \*(Aqcurrent_pagenum\*(Aq, and a \*(Aqurl\*(Aq to get back to this page:
\& 
\& [%\- PROCESS page_count( total_pages     = 5,
\&                         current_pagenum = 3,
\&                         url             = url ) \-%]
\& 
\& Displays:
\& 
\& Page [<<] [1] [2] 3 [4] [5] [>>]
\& 
\& (Where the items enclosed by \*(Aq[]\*(Aq are links.)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class has methods to enable you to easily create paged result
lists. This includes saving your results to disk, retrieving them
easily and some simple calculation functions for page number
determination.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
The following methods are public and available for OpenInteract
application developers.
.PP
\&\fBsave( \f(CB$stuff_to_save\fB, \e%params )\fR
.PP
Saves a list of things to be retrieved later. The \f(CW$stuff_to_save\fR
can be an arrayref of \s-1ID\s0 values (simple scalars), an arrayref of \s-1SPOPS\s0
objects, or an SPOPS::Iterator implementation all
primed and ready to go. If objects are passed in via a list or an
iterator, we call \f(CW\*(C`\->id()\*(C'\fR on each to get the \s-1ID\s0 value to save.
.PP
If objects are used, we also query each one for its class and save
that information in the search results. Whether you have a homogenous
resultset or not affects the return values. If it is a homogenous
resultset we note the class for all objects in the search results
metadata, which is saved in a separate file from the results
themselves. This enables us to create an iterator from the results if
needed.
.PP
Parameters:
.IP "\(bu" 4
\&\fBclass\fR ($) (optional)
.Sp
You can force all the IDs passed in to be of a particular class.
.IP "\(bu" 4
\&\fBextra\fR (\e@) (optional)
.Sp
Each item represents extra information to save along with each
result. Each item must be either a scalar (which saves one extra item)
or an arrayref (which saves a number of extra items).
.IP "\(bu" 4
\&\fBextra_name\fR (\e@)  (optional)
.Sp
If you specify extra information you need to give each one a name.
.PP
Returns: an \s-1ID\s0 you can use to retrieve the search results using
the \f(CW\*(C`retrieve()\*(C'\fR or \f(CW\*(C`retrieve_iterator()\*(C'\fR methods. If
you misplace the \s-1ID\s0, you cannot get the search results back.
.PP
Side effects: the \s-1ID\s0 returned is also saved in the 'search_id' key of
the object itself.
.PP
Example:
.PP
.Vb 5
\& my $results = OpenInteract2::ResultsManage\->new();
\& my $search_id = $results\->save({ \e@results,
\&                                  { force_mixed => 1,
\&                                    extra       => \e@extra_info,
\&                                    extra_name  => [ \*(Aqhit_count\*(Aq, \*(Aqweight\*(Aq ] });
.Ve
.PP
The following parameters are set in the object after a successful
results save:
.PP
.Vb 2
\& search_id
\& num_records
.Ve
.PP
Returns: the \s-1ID\s0 of the search just saved.
.PP
\&\fBretrieve( \f(CB$search_id\fB, \e%params )\fR
.PP
Retrieve previously saved search results using the parameter
\&'search_id' which should be set on initialization or before this
method is run.
.PP
Parameters:
.IP "\(bu" 4
\&\fBmin\fR: Where we should start grabbing the results. Generally used if
you are using a paged results scheme, (page 1 is 1 \- 25, page 2 26 \-
50, etc.). (Can be set at object creation.)
.IP "\(bu" 4
\&\fBmax\fR: Where should we stop grabbing the results. See \fBmin\fR. (Can be
set at object creation.)
.PP
Returns:
.IP "\(bu" 4
\&\fBIn list context\fR: an array with the first element an arrayref of the
results (or IDs of the results), the second element an arrayref of the
classes used in the results, the third element being the total number
of items saved. (The total number of items can be helpful when
creating pagecounts.)
.IP "\(bu" 4
\&\fBIn scalar context\fR: an arrayref of the results.
.PP
Note: The interface for this method may change, and we might split
apart the different return results into two methods (particularly
whether classes are involved).
.PP
Also sets the object parameters:
.PP
\&'num_records' \- total number of results in the original search
.PP
\&'date' \- date the search was run
.PP
\&'num_extra' \- number of 'extra' records saved
.PP
\&'extra_name' (\e@) \- list of fields matching extra values saved
.PP
\&\fBretrieve_iterator( \f(CB$search_id\fB, \e%params )\fR
.PP
Retrieves an iterator to walk the results. You can use min/max to
pre-separate or you can simply grab all the results and screen them
out yourself.
.PP
Parameters: same as \f(CW\*(C`retrieve()\*(C'\fR
.PP
\&\fBget_metadata( \f(CB$search_id\fB )\fR
.PP
Fetch metadata only about a search. Returns a hashref with the
following keys:
.IP "\(bu" 4
\&\fBtime\fR \- results storage time in epoch seconds
.IP "\(bu" 4
\&\fBdate\fR \- results storage time in human-readable format
.IP "\(bu" 4
\&\fBnum_records\fR \- number of records stored
.IP "\(bu" 4
\&\fBfilename\fR \- name of file (only the filename)
.IP "\(bu" 4
\&\fBdirectory\fR \-
.PP
\&\fBfind_total_page_count( \f(CB$records_per_page\fB, [ \f(CB$num_records\fB ] )\fR
.PP
If called as an object then use 'num_records' property of object. If
\&'num_records' is not in the object, or if you call this as a class
method, then we use the second parameter for the total number of
records.
.PP
Returns: Number of pages required to display \f(CW$num_records\fR at
\&\f(CW$records_per_page\fR.
.PP
Example:
.PP
.Vb 2
\& my $page_count = $class\->find_total_page_count( 289, 25 );
\& # $page_count = 11
\& 
\& my $page_count = $class\->find_total_page_count( 289, 75 );
\& # $page_count = 4
.Ve
.PP
\&\fBfind_page_boundaries( \f(CB$page_number\fB, \f(CB$records_per_page\fB )\fR
.PP
Returns: An array with the floor and ceiling values to display the
given page with \f(CW$records_per_page\fR on the page.
.PP
Example:
.PP
.Vb 2
\& my ( $min, $max ) = $class\->find_page_boundaries( 3, 75 );
\& # $min is 226, $max is 300
\&
\& my ( $min, $max ) = $class\->find_page_boundaries( 12, 25 );
\& # min is 301, $max is 325
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
\&\fB\f(BI_build_results_filename()\fB\fR
.PP
\&\fB\f(BIgenerate_search_id()\fB\fR
.PP
\&\fB\f(BI_lock_results()\fB\fR
.PP
\&\fB\f(BI_unlock_results()\fB\fR
.PP
\&\fB\f(BI_clear_results()\fB\fR
.PP
\&\fB\f(BI_retrieve_raw_results()\fB\fR
.SH "DATA FORMAT"
.IX Header "DATA FORMAT"
Here is an example of a saved resultset. This one happens to be
generated by the OpenInteract2::FullText
module.
.PP
.Vb 4
\& Thu Jul 12 17:19:05 2001\-\->3\-\->\-\->1\-\->fulltext_score
\& \-\->3d5676e0af1f1cc6b539fb08a5ee67b7\-\->2
\& \-\->c3d72c3c568d99a796b23e8efc75c00f\-\->1
\& \-\->8f10f3a91c3f10c876805ab1d76e1b94\-\->1
.Ve
.PP
Here are all the pieces:
.PP
\&\fBFirst\fR, the separator is \f(CW\*(C`\-\->\*(C'\fR. This is configurable in this
module.
.PP
\&\fBSecond\fR, the first line has:
.IP "\(bu" 4
\&\f(CW\*(C`Thu Jul 12 17:19:05 2001\*(C'\fR
.Sp
The date the search was originally run.
.IP "\(bu" 4
\&\f(CW3\fR
.Sp
The number of items in the entire search resultset.
.IP "\(bu" 4
\&\f(CW\*(C`\*(C'\fR (empty)
.Sp
If it were filled it would be either a classname (e.g.,
\&'MySite::User') or the keyword '\s-1MIXED\s0' which tells this class that the
results are of multiple classes.
.IP "\(bu" 4
\&\f(CW1\fR
.Sp
The number of 'extra' fields.
.IP "\(bu" 4
\&\f(CW\*(C`fulltext_score\*(C'\fR
.Sp
The name of the first 'extra' field. If there wore than one extra
field they would be separated with commas.
.PP
\&\fBThird\fR, the second and remaining line have three pieces:
.IP "\(bu" 4
\&\f(CW\*(C`\*(C'\fR (empty)
.Sp
The class name for this result. Since these IDs are not from a class,
there is no class name.
.Sp
\&\f(CW\*(C`3d5676e0af1f1cc6b539fb08a5ee67b7\*(C'\fR
.Sp
The main value returned, also the \s-1ID\s0 of the object returned that, when
matched with the class name (first item) would be able to define an
object to be fetched.
.Sp
\&\f(CW2\fR
.Sp
The first 'extra' value. Successive 'extra' values are separated by
\&'\-\->' like the other fields.
.SH "BUGS"
.IX Header "BUGS"
None known, although the \s-1API\s0 may change in the near future.
.SH "TO DO"
.IX Header "TO DO"
\&\fBReview \s-1API\s0\fR
.PP
The \s-1API\s0 is currently unstable but should solidify quickly as we get
more use out of this module.
.PP
.Vb 2
\& \- Keep \*(Aqmixed\*(Aq stuff in there, or maybe always treat the resultset as
\& potentially heterogeneous objects?
\&
\& \- Test with saving different types of non\-object data as well as
\& objects and see if the usage holds up (including with the
\& ResultsIterator).
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
