.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenInteract2::Config::Ini 3"
.TH OpenInteract2::Config::Ini 3 "2010-06-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenInteract2::Config::Ini \- Read/write INI\-style (++) configuration files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # If no \*(Aqdirectory\*(Aq specified @INCLUDE directives are assumed to be
\& # in the same directory as the \*(Aqfilename\*(Aq
\&
\& my $config = OpenInteract2::Config::Ini\->new({
\&     filename => \*(Aqmyconf.ini\*(Aq
\& });
\& 
\& # Pass in an explicit directory to resolve @INCLUDE directives
\& 
\& my $config = OpenInteract2::Config::Ini\->new({
\&     filename  => \*(Aqmyconf.ini\*(Aq,
\&     directory => \*(Aq/path/to/config\*(Aq,
\& });
\& 
\& # Use a string with INI sections instead of a file; @INCLUDE
\& # directives assumed to be in the current directory
\& 
\& my $config = OpenInteract2::Config::Ini\->new({
\&     content  => $some_string,
\& });
\&
\& # Pass in an explicit directory to resolve @INCLUDE directives
\& 
\& my $config = OpenInteract2::Config::Ini\->new({
\&     content   => $some_string,
\&     directory => \*(Aq/path/to/config\*(Aq,
\& });
\& 
\& # Use the configuration just like a hash
\& print "Main database driver is:", $config\->{datasource}{main}{driver}, "\en";
\& $config\->{datasource}{main}{username} = \*(Aqmariolemieux\*(Aq;
\&
\& # Write out the configuration; this should preserve order and
\& # comments
\& 
\& $config\->write_file;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a very simple implementation of a configuration file
reader/writer that preserves comments and section order, enables
multivalue fields, enables multi-line values, and has one or two-level
sections.
.PP
Yes, there are other configuration file modules out there to
manipulate INI-style files. But this one takes several features from
them while providing a very simple and uncluttered interface.
.IP "\(bu" 4
From Config::IniFiles we take comment preservation
and the idea that we can have multi-level sections like:
.Sp
.Vb 1
\& [Section subsection]
.Ve
.IP "\(bu" 4
From Config::Ini and AppConfig we borrow
the usage of multivalue keys:
.Sp
.Vb 2
\& item = first
\& item = second
.Ve
.IP "\(bu" 4
From an idea I had in the shower we have another usage of multivalue
keys:
.Sp
.Vb 1
\& @,item = first, second
.Ve
.Sp
The leading '@' indicates we are declaring multiple values, the next
character ',' indicates that we are separating the values with a
comma. So you could also have:
.Sp
.Vb 1
\& @|item = first | second
.Ve
.Sp
Similar to how we treat the '=' we swallow whitespace on both sides of
the separation character. So the following evaluate to equivalent data
structures:
.Sp
.Vb 3
\& @,item = first,second
\& @,item = first, second
\& @,item = first  ,   second
.Ve
.Sp
You can also use multiple declarations of these to define a single
field. That should prevent configuration lines from getting too long:
.Sp
.Vb 3
\& @,object_field = title, posted_on_date, author, editor
\& @,object_field = approved_by, approved_on, is_active,
\& @,object_field = active_on, content
.Ve
.IP "\(bu" 4
From countless other configuration systems you can include the
contents of other files inline using '@INCLUDE'. So given the
following files:
.Sp
.Vb 5
\& File: db_config.ini
\& [db]
\& dsn = DBI:Pg:dbname=foo
\& user = foo
\& password = bar
\& 
\& File: caching.ini
\& [cache]
\& use = no
\& expiration = 600
\& class = OpenInteract2::Cache::File
\& 
\& [cache params]
\& directory = /path/to/cache
\& lock_directory = /path/to/cache_lock
.Ve
.Sp
You can them bring them all together in one with:
.Sp
.Vb 4
\& File: server.ini
\& [Global]
\& version = 1.19
\& timezone = America/New_York
\& 
\& @INCLUDE = db_config.ini
\& @INCLUDE = caching.ini
.Ve
.SS "Example"
.IX Subsection "Example"
Given the following configurations:
.PP
.Vb 4
\& [datasource]
\& default_connection_db = main
\& db                    = main
\& db                    = other
\&
\& [db_info main]
\& db_owner      =
\& username      = captain
\& password      = whitman
\& dsn           = dbname=usa
\& db_name       =
\& driver_name   = Pg
\& sql_install   =
\& long_read_len = 65536
\& long_trunc_ok = 0
\& comment       = this is the database for mr whitman who \e
\& is not feeling very well as of late
\&
\& [db_info other]
\& db_owner      =
\& username      = tyger
\& password      = blake
\& dsn           = dbname=britain
\& db_name       =
\& driver_name   = Pg
\& sql_install   =
\& long_read_len = 65536
\& long_trunc_ok = 0
.Ve
.PP
You would get the following Perl data structure:
.PP
.Vb 10
\& $config = {
\&   datasource => {
\&      default_connection_db => \*(Aqmain\*(Aq,
\&      db                    => [ \*(Aqmain\*(Aq, \*(Aqother\*(Aq ],
\&   },
\&   db_info => {
\&      main => {
\&           db_owner      => undef,
\&           username      => \*(Aqcaptain\*(Aq,
\&           password      => \*(Aqwhitman\*(Aq,
\&           dsn           => \*(Aqdbname=usa\*(Aq,
\&           db_name       => undef,
\&           driver_name   => \*(AqPg\*(Aq,
\&           sql_install   => undef,
\&           long_read_len => \*(Aq65536\*(Aq,
\&           long_trunc_ok => \*(Aq0\*(Aq,
\&           comment       => \*(Aqthis is the database for mr whitman who is not feeling very well as of late\*(Aq,
\&      },
\&      other => {
\&           db_owner      => undef,
\&           username      => \*(Aqtyger\*(Aq,
\&           password      => \*(Aqblake\*(Aq,
\&           dsn           => \*(Aqdbname=britain\*(Aq,
\&           db_name       => undef,
\&           driver_name   => \*(AqPg\*(Aq,
\&           sql_install   => undef,
\&           long_read_len => \*(Aq65536\*(Aq,
\&           long_trunc_ok => \*(Aq0\*(Aq,
\&      },
\&   },
\& };
.Ve
.SS "'Global' Key"
.IX Subsection "'Global' Key"
Anything under the 'Global' key in the configuration will be available
under the configuration object root. For instance:
.PP
.Vb 2
\& [Global]
\& DEBUG = 1
.Ve
.PP
will be available as:
.PP
.Vb 1
\& $CONFIG\->{DEBUG}
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\&\fBnew( \e%params )\fR
.PP
Create a new configuration object. If you pass in 'filename' as a
parameter we will parse the file and fill the returned object with its values.
.PP
If you pass in raw \s-1INI\s0 text in the parameter 'content' we try to
translate it using the same means as reading a file.
.PP
\&\fB\s-1NOTE:\s0 \s-1THIS\s0 \s-1DOES\s0 \s-1NOT\s0 \s-1WORK\s0 \s-1YET\s0\fR And if you pass in a hashref in the
parameter 'struct' we attempt to map its keys and values to the
internal format which can then be saved as normal. This will throw an
exception if your structures are nested too deeply. For instance, this
would be ok:
.PP
.Vb 4
\& my $foo = {
\&    top_key => { myvalue => 1, yourvalue => [ \*(Aqone\*(Aq, \*(Aqtwo\*(Aq ] },
\&    bottom_key => { other => { mine => \*(Aq1\*(Aq, yours => 2 }, bell => \*(Aqweather\*(Aq },
\& };
.Ve
.PP
As it would represent:
.PP
.Vb 4
\& [top_key]
\& myvalue = 1
\& yourvalue = one
\& yourvalue = two
\&
\& [bottom_key]
\& bell = weather
\&
\& [bottom_key other]
\& mine = 1
\& yours = 2
.Ve
.PP
But the following has references nested too deeply:
.PP
.Vb 10
\& my $foo = {
\&    top_key => {
\&        myvalue => 1,
\&        yourvalue => [ \*(Aqone\*(Aq, \*(Aqtwo\*(Aq ]
\&    },
\&    bottom_key => {
\&        other => {
\&            mine => {              <\-\-\- this key\*(Aqs value is too deep
\&                zaphod => \*(Aqtowel\*(Aq,
\&            },
\&            yours => {             <\-\-\- this key\*(Aqs value is too deep
\&               abe => \*(Aqhonest\*(Aq,
\&            },
\&        }
\&        bell => \*(Aqweather\*(Aq,
\&    },
\& };
.Ve
.PP
Returns: a new
OpenInteract2::Config::Ini object
.SS "Object Methods"
.IX Subsection "Object Methods"
\&\fB\f(BIas_data()\fB\fR
.PP
Get the data back from the object as an unblessed hash reference.
.PP
\&\fB\f(BIsections()\fB\fR
.PP
Returns a list of available sections.
.PP
\&\fBget( \f(CB$section\fB, [ \f(CB$sub_section\fB ], \f(CB$parameter\fB )\fR
.PP
Returns the value from \f(CW$section\fR (and \f(CW$sub_section\fR, if given) for
\&\f(CW$parameter\fR.
.PP
Returns: value set in config. If called in array context and there are
multiple values for \f(CW$parameter\fR, returns an array. Otherwise returns
a simple scalar if there is one value, or an arrayref if multiple
values.
.PP
\&\fBset( \f(CB$section\fB, [ \f(CB$sub_section\fB ], \f(CB$parameter\fB, \f(CB$value\fB )\fR
.PP
Set the key/value \f(CW$parameter\fR/\f(CW$value\fR pair in the
configuration. Note that \f(CW$value\fR can be a simple scalar or an array
reference.
.PP
Returns: the value set
.PP
\&\fBdelete( \f(CB$section\fB, [ \f(CB$sub_section\fB ])\fR
.PP
Remove the \f(CW$section\fR (and \f(CW$sub_section\fR, if given) entirely.
.PP
Returns: the value deleted
.PP
\&\fBwrite_file( \f(CB$filename\fB )\fR
.PP
Serializes the \s-1INI\s0 file (with comments, as applicable) to
\&\f(CW$filename\fR.
.PP
Note: this \fB\s-1DOES\s0 \s-1NOT\s0\fR write any '@INCLUDE' directives back to the
files we read them from. Everything will be written to the same
file. (Patches welcome if you would like to change this, probably by
tagging the sections read in from a file with that absolute filename
and then writing those sections back out to the file from this
method.)
.PP
Items from the config object root go into 'Global'.
.PP
Returns: the filename to which the \s-1INI\s0 structure was serialized.
.SS "Debugging Note"
.IX Subsection "Debugging Note"
Configuration input and output can generate a ton of logging
information, so it uses a separate logging category '\s-1LOG_CONFIG\s0' as
imported from
OpenInteract2::Constants. Set this to
\&\f(CW\*(C`DEBUG\*(C'\fR with fair warning...
.SS "Internal Methods"
.IX Subsection "Internal Methods"
\&\fB_translate_ini( \e@lines|$content )\fR
.PP
Translate the arrayref \f(CW\*(C`\e@lines\*(C'\fR or the scalar \f(CW\*(C`content\*(C'\fR from \s-1INI\s0
format into a Perl data structure. Before we translate them into a
data structure we first resolve all '@INCLUDE' directives.
.PP
Returns: the object filled with the content.
.PP
\&\fB_resolve_all_includes( \e@lines )\fR
.PP
Translate all '@INCLUDE' directives to the configuration they point
to. Throws an exception if we cannot read the file specified in the
directive. This file path is created by giving to \f(CW\*(C`catfile\*(C'\fR in
File::Spec the metadata value 'directory' (which can be passed in
to \f(CW\*(C`new()\*(C'\fR) and the filename in the directive.
.PP
Note that INCLUDE-ed files can themselves have '@INCLUDE' directives.
.PP
Returns: arrayref of fully-resolved configuration.
.PP
\&\fB_read_section_head( \f(CB$full_section\fB, \e@comments )\fR
.PP
Splits the section into a section and sub-section, returning a
two-item list. Also puts the full section in the object internal order
and puts the comments so they can be linked to the section.
.PP
Returns: a two-item list with the section and sub-section as
elements. If the section is only one-level deep, it is the first and
only member.
.PP
\&\fB_read_item( \f(CB$section\fB, \f(CB$subsection\fB, \f(CB$parameter\fB, \f(CB$value\fB )\fR
.PP
Reads the value from [\f(CW$section\fR \f(CW$subsection\fR] into the object. If
the \f(CW$section\fR is 'Global' we set the \f(CW$parameter\fR and \f(CW$value\fR
at the root level.
.PP
Returns: the value set
.PP
\&\fB_set_value( \e%values, \f(CB$parameter\fB, \f(CB$value\fB )\fR
.PP
Note that \f(CW$value\fR can be a simple scalar or an array reference.
.PP
Sets \f(CW$parameter\fR to \f(CW$value\fR in \f(CW\*(C`\e%values\*(C'\fR. We do not care where
\&\f(CW\*(C`\e%values\*(C'\fR is in the tree.
.PP
If a value already exists for \f(CW$parameter\fR, we make the value of
\&\f(CW$parameter\fR an arrayref and push \f(CW$value\fR onto it.
.PP
\&\fB_output_section( \f(CB$section\fB, \f(CB$sub_section\fB )\fR
.PP
Serializes the section \f(CW$section\fR and \f(CW$sub_section\fR.
.PP
Returns: a scalar suitable for output.
.PP
\&\fB_show_item( \f(CB$parameter\fB, \f(CB$value\fB )\fR
.PP
Serialize the key/value pair.
.PP
Returns: \*(L"$parameter = \f(CW$value\fR\*(R"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AppConfig
.PP
Config::Ini
.PP
Config::IniFiles
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2005 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
